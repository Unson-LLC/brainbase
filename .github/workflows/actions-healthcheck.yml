name: Actions Healthcheck

on:
  workflow_dispatch:
  schedule:
    - cron: '0,30 0-14 * * *'  # JST 09:00-23:00

permissions:
  contents: read
  actions: read

jobs:
  healthcheck:
    runs-on: ubuntu-latest
    env:
      REPOS: |
        sintariran/brainbase
      MAX_AGE_HOURS: "24"
    steps:
      - name: Check workflows and runners
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_MONITOR_PAT || github.token }}
          script: |
            const repos = process.env.REPOS.trim().split(/\s+/);
            const maxAgeHours = Number(process.env.MAX_AGE_HOURS || 24);
            const maxAgeMs = maxAgeHours * 60 * 60 * 1000;
            const now = Date.now();
            const issues = [];
            const runnerAlerts = [];

            for (const repo of repos) {
              const [owner, name] = repo.split('/');
              const runs = await github.paginate(
                github.rest.actions.listWorkflowRunsForRepo,
                { owner, repo: name, per_page: 50, status: 'completed', exclude_pull_requests: true }
              );
              const recentFailed = runs.filter(
                (r) => r.conclusion !== 'success' &&
                       (now - new Date(r.created_at).getTime()) <= maxAgeMs
              );
              recentFailed.forEach(failed => {
                // Check if there's a subsequent success for the same workflow
                const hasSubsequentSuccess = runs.some(
                  (r) => r.name === failed.name &&
                         r.conclusion === 'success' &&
                         new Date(r.created_at).getTime() > new Date(failed.created_at).getTime()
                );
                if (!hasSubsequentSuccess) {
                  issues.push({
                    repo,
                    workflow: failed.name,
                    html_url: failed.html_url,
                    conclusion: failed.conclusion,
                    created_at: failed.created_at,
                  });
                }
              });

              const runners = await github.paginate(
                github.rest.actions.listSelfHostedRunnersForRepo,
                { owner, repo: name, per_page: 50 }
              );
              runners
                .filter((r) => r.labels.some((l) => l.name === 'self-hosted'))
                .filter((r) => r.status !== 'online')
                .forEach((r) => runnerAlerts.push({ repo, name: r.name, status: r.status }));
            }

            core.setOutput('has_issues', issues.length > 0 || runnerAlerts.length > 0 ? 'true' : 'false');
            core.setOutput('issues', JSON.stringify(issues));
            core.setOutput('issues_text', issues.map(i => `• ${i.repo}: ${i.workflow} (${i.conclusion}) -> ${i.html_url}`).join('\n'));
            core.setOutput('runner_alerts', JSON.stringify(runnerAlerts));
            core.setOutput('runner_text', runnerAlerts.map(r => `• ${r.repo}: runner ${r.name} is ${r.status}`).join('\n'));

      - name: Notify Slack (issues or runners)
        if: steps.check.outputs.has_issues == 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          ISSUES_TEXT: ${{ steps.check.outputs.issues_text }}
          RUNNER_TEXT: ${{ steps.check.outputs.runner_text }}
        run: |
          text="[Actions Healthcheck]\n"
          [ -n "$ISSUES_TEXT" ] && text+="❌ Failed workflows (24h):\n$ISSUES_TEXT\n"
          [ -n "$RUNNER_TEXT" ] && text+="⚠️ Offline self-hosted runners:\n$RUNNER_TEXT\n"

          if [ -n "$SLACK_BOT_TOKEN" ] && [ -n "$SLACK_CHANNEL_ID" ]; then
            curl -sS -X POST https://slack.com/api/chat.postMessage \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H 'Content-type: application/json; charset=utf-8' \
              --data "$(jq -n --arg channel "$SLACK_CHANNEL_ID" --arg text "$text" '{channel:$channel,text:$text}')"
          elif [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -sS -X POST -H 'Content-type: application/json' --data "$(jq -Rn --arg t "$text" '{text: $t}')" "$SLACK_WEBHOOK_URL"
          else
            echo "No Slack config; skipping notification."
          fi

      - name: No issues found
        if: steps.check.outputs.has_issues != 'true'
        run: echo "No failures or offline runners in the last ${MAX_AGE_HOURS}h."
