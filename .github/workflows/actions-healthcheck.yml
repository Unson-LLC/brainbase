name: brainbase Healthcheck

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0-14/2 * * *'  # JST 09:00, 11:00, 13:00, 15:00, 17:00, 19:00, 21:00, 23:00

permissions:
  contents: read
  actions: read

jobs:
  healthcheck:
    runs-on: ubuntu-latest
    env:
      REPOS: |
        sintariran/brainbase
      MAX_AGE_HOURS: "12"
    steps:
      - name: Check workflows and runners
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_MONITOR_PAT || github.token }}
          script: |
            const repos = process.env.REPOS.trim().split(/\s+/);
            const maxAgeHours = Number(process.env.MAX_AGE_HOURS || 24);
            const maxAgeMs = maxAgeHours * 60 * 60 * 1000;
            const now = Date.now();
            const issues = [];
            const runnerAlerts = [];

            for (const repo of repos) {
              const [owner, name] = repo.split('/');
              const runs = await github.paginate(
                github.rest.actions.listWorkflowRunsForRepo,
                { owner, repo: name, per_page: 50, status: 'completed', exclude_pull_requests: true, branch: 'main' }
              );
              const recentFailed = runs.filter(
                (r) => r.conclusion !== 'success' &&
                       (now - new Date(r.created_at).getTime()) <= maxAgeMs
              );
              recentFailed.forEach(failed => {
                // Check if there's a subsequent success for the same workflow (by path)
                const hasSubsequentSuccess = runs.some(
                  (r) => r.path === failed.path &&
                         r.conclusion === 'success' &&
                         new Date(r.created_at).getTime() > new Date(failed.created_at).getTime()
                );
                if (!hasSubsequentSuccess) {
                  issues.push({
                    repo,
                    workflow: failed.name,
                    html_url: failed.html_url,
                    conclusion: failed.conclusion,
                    created_at: failed.created_at,
                  });
                }
              });

              const runners = await github.paginate(
                github.rest.actions.listSelfHostedRunnersForRepo,
                { owner, repo: name, per_page: 50 }
              );
              runners
                .filter((r) => r.labels.some((l) => l.name === 'self-hosted'))
                .filter((r) => r.status !== 'online')
                .forEach((r) => runnerAlerts.push({ repo, name: r.name, status: r.status }));
            }

            core.setOutput('has_issues', issues.length > 0 || runnerAlerts.length > 0 ? 'true' : 'false');
            core.setOutput('issues', JSON.stringify(issues));
            core.setOutput('issues_text', issues.map(i => `‚Ä¢ ${i.repo}: ${i.workflow} (${i.conclusion}) -> ${i.html_url}`).join('\n'));
            core.setOutput('runner_alerts', JSON.stringify(runnerAlerts));
            core.setOutput('runner_text', runnerAlerts.map(r => `‚Ä¢ ${r.repo}: runner ${r.name} is ${r.status}`).join('\n'));

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Check Lambda errors
        id: lambda-check
        run: |
          LAMBDA_FUNCTIONS="mana mana-salestailor mana-techknight"
          SINCE_MINUTES=30
          LAMBDA_ERRORS=""
          TOOL_ERROR_SUMMARY=""

          for fn in $LAMBDA_FUNCTIONS; do
            echo "Checking $fn..."

            # Get CloudWatch logs from the last 30 minutes
            LOGS=$(aws logs tail "/aws/lambda/$fn" --since ${SINCE_MINUTES}m --format short 2>&1 || echo "")

            # Check for error patterns
            ERROR_LINES=$(echo "$LOGS" | grep -iE "ERROR|Exception|SyntaxError|Runtime\..*Error" | head -5 || echo "")

            # Count tool-specific errors
            TOOL_ERRORS=$(echo "$LOGS" | grep -i "tool.*error\|failed to execute\|search.*error\|source-code.*error" || echo "")
            TOOL_ERROR_COUNT=$(echo "$TOOL_ERRORS" | grep -v "^$" | wc -l | tr -d ' ')

            # Count total tool invocations
            TOOL_INVOCATIONS=$(echo "$LOGS" | grep -iE "\[.*tool\]|\[source-code\]|\[search\]" || echo "")
            TOOL_INVOCATION_COUNT=$(echo "$TOOL_INVOCATIONS" | grep -v "^$" | wc -l | tr -d ' ')

            # Calculate error rate
            if [ "$TOOL_INVOCATION_COUNT" -gt 0 ]; then
              ERROR_RATE=$(awk "BEGIN {printf \"%.1f\", ($TOOL_ERROR_COUNT / $TOOL_INVOCATION_COUNT) * 100}")
              TOOL_ERROR_SUMMARY+="üìä $fn: ${TOOL_ERROR_COUNT}/${TOOL_INVOCATION_COUNT} errors (${ERROR_RATE}%)\n"

              # Alert if error rate > 5%
              if (( $(echo "$ERROR_RATE > 5.0" | bc -l) )); then
                LAMBDA_ERRORS+="‚ö†Ô∏è $fn „ÉÑ„Éº„É´„Ç®„É©„ÉºÁéá: ${ERROR_RATE}% (ÁõÆÊ®ô: <5%)\n"
              fi
            fi

            if [ -n "$ERROR_LINES" ]; then
              LAMBDA_ERRORS+="üî¥ Lambda $fn:\n"
              # Format error lines
              while IFS= read -r line; do
                # Truncate long lines
                truncated=$(echo "$line" | cut -c1-200)
                LAMBDA_ERRORS+="  ${truncated}\n"
              done <<< "$ERROR_LINES"
              LAMBDA_ERRORS+="\n"
            fi
          done

          if [ -n "$LAMBDA_ERRORS" ]; then
            echo "lambda_errors<<EOF" >> $GITHUB_OUTPUT
            echo -e "$LAMBDA_ERRORS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "has_lambda_errors=true" >> $GITHUB_OUTPUT
          else
            echo "has_lambda_errors=false" >> $GITHUB_OUTPUT
            echo "All Lambda functions healthy (last ${SINCE_MINUTES}m)"
          fi

          # Output tool error summary
          if [ -n "$TOOL_ERROR_SUMMARY" ]; then
            echo "tool_error_summary<<EOF" >> $GITHUB_OUTPUT
            echo -e "$TOOL_ERROR_SUMMARY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Notify Slack (issues or runners or Lambda errors)
        if: steps.check.outputs.has_issues == 'true' || steps.lambda-check.outputs.has_lambda_errors == 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}
          ISSUES_TEXT: ${{ steps.check.outputs.issues_text }}
          RUNNER_TEXT: ${{ steps.check.outputs.runner_text }}
          LAMBDA_ERRORS_TEXT: ${{ steps.lambda-check.outputs.lambda_errors }}
          TOOL_ERROR_SUMMARY: ${{ steps.lambda-check.outputs.tool_error_summary }}
        run: |
          text="[brainbase Healthcheck]\n"
          [ -n "$ISSUES_TEXT" ] && text+="‚ùå Failed workflows (12h):\n$ISSUES_TEXT\n"
          [ -n "$RUNNER_TEXT" ] && text+="‚ö†Ô∏è Offline self-hosted runners:\n$RUNNER_TEXT\n"
          [ -n "$LAMBDA_ERRORS_TEXT" ] && text+="üî¥ Lambda errors (30m):\n$LAMBDA_ERRORS_TEXT\n"
          [ -n "$TOOL_ERROR_SUMMARY" ] && text+="üìä Tool Error Rates (30m):\n$TOOL_ERROR_SUMMARY\n"

          if [ -n "$SLACK_BOT_TOKEN" ] && [ -n "$SLACK_CHANNEL_ID" ]; then
            curl -sS -X POST https://slack.com/api/chat.postMessage \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              -H 'Content-type: application/json; charset=utf-8' \
              --data "$(jq -n --arg channel "$SLACK_CHANNEL_ID" --arg text "$text" '{channel:$channel,text:$text}')"
          elif [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -sS -X POST -H 'Content-type: application/json' --data "$(jq -Rn --arg t "$text" '{text: $t}')" "$SLACK_WEBHOOK_URL"
          else
            echo "No Slack config; skipping notification."
          fi

      - name: No issues found
        if: steps.check.outputs.has_issues != 'true' && steps.lambda-check.outputs.has_lambda_errors != 'true'
        run: echo "‚úÖ All systems healthy - no workflow failures, offline runners, or Lambda errors detected."
