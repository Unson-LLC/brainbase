#!/usr/bin/env python3
"""ISMP/ISM docx から脆弱性一覧を抽出する。

TSVで出力する。--format json を指定するとJSON配列で出力する。
"""

from __future__ import annotations

import argparse
import json
import re
import sys
import zipfile
import xml.etree.ElementTree as ET
from typing import Dict, List

NS = {"w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"}


def read_document_xml(docx_path: str) -> str:
    with zipfile.ZipFile(docx_path) as zf:
        return zf.read("word/document.xml").decode("utf-8", errors="ignore")


def extract_paragraphs(xml_text: str) -> List[str]:
    root = ET.fromstring(xml_text)
    paragraphs: List[str] = []
    for p in root.findall(".//w:p", NS):
        texts = [t.text for t in p.findall(".//w:t", NS) if t.text]
        if not texts:
            continue
        text = "".join(texts).strip()
        if text:
            paragraphs.append(text)
    return paragraphs


def split_sections(paragraphs: List[str]) -> List[List[str]]:
    starts = [i for i, t in enumerate(paragraphs) if t == "対策期限(システム単位)"]
    sections: List[List[str]] = []
    for idx, start in enumerate(starts):
        end = starts[idx + 1] if idx + 1 < len(starts) else len(paragraphs)
        sections.append(paragraphs[start:end])
    return sections


def get_after(label: str, section: List[str]) -> str | None:
    try:
        i = section.index(label)
    except ValueError:
        return None
    if i + 1 < len(section):
        return section[i + 1]
    return None


def extract_records(sections: List[List[str]]) -> List[Dict[str, str]]:
    records: List[Dict[str, str]] = []
    for sec in sections:
        rec: Dict[str, str] = {}
        rec["due"] = get_after("対策期限(システム単位)", sec) or ""
        rec["vuln_id"] = get_after("脆弱性ID", sec) or ""
        rec["title"] = get_after("タイトル", sec) or ""
        rec["risk"] = get_after("リスクレベル", sec) or ""
        rec["cvss_v3"] = get_after("CVSSv3（基本値）", sec) or ""

        os_match = re.search(r"Ubuntu\s+\d+\.\d+\s+LTS", rec["title"])
        rec["target_os"] = os_match.group(0) if os_match else ""
        records.append(rec)

    # 脆弱性ID+タイトルで重複排除
    seen = set()
    unique: List[Dict[str, str]] = []
    for rec in records:
        key = (rec.get("vuln_id"), rec.get("title"))
        if key in seen:
            continue
        seen.add(key)
        unique.append(rec)
    return unique


def main() -> int:
    parser = argparse.ArgumentParser(description="ISMP/ISM docx から脆弱性一覧を抽出")
    parser.add_argument("--input", required=True, help="入力docxのパス")
    parser.add_argument("--output", help="出力ファイル（省略時は標準出力）")
    parser.add_argument("--format", choices=["tsv", "json"], default="tsv")
    args = parser.parse_args()

    xml_text = read_document_xml(args.input)
    paragraphs = extract_paragraphs(xml_text)
    sections = split_sections(paragraphs)
    records = extract_records(sections)

    out = sys.stdout
    if args.output:
        out = open(args.output, "w", encoding="utf-8")

    try:
        if args.format == "json":
            json.dump(records, out, ensure_ascii=False, indent=2)
            out.write("\n")
        else:
            header = ["vuln_id", "title", "target_os", "risk", "cvss_v3", "due"]
            out.write("\t".join(header) + "\n")
            for rec in records:
                row = [rec.get(k, "") for k in header]
                out.write("\t".join(row) + "\n")
    finally:
        if args.output:
            out.close()

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
