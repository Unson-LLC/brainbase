{
  "status": "skipped",
  "reason": "refactor_not_performed",
  "details": {
    "attempt": 1,
    "area": "server/services",
    "failure": {
      "reason": "codex_timeout",
      "details": {
        "area": "server/services",
        "message": "Codex CLI exited with code 1: OpenAI Codex v0.98.0 (research preview)\n--------\nworkdir: /Users/ksato/actions-runner/_work/brainbase/brainbase\nmodel: gpt-5-codex\nprovider: openai\napproval: never\nsandbox: danger-full-access\nreasoning effort: high\nreasoning summaries: auto\nsession id: 019c5a28-16bc-7533-90d4-dfe1fc1e5add\n--------\nuser\nYou are the Refactoring Specialist in the ops-department.\n\nYour role: Identify and IMPLEMENT actual refactoring improvements in the codebase.\n\nSkills you have access to:\n- refactoring-workflow: 3-Phase段階的移行、既存機能保護\n- verify-first-debugging: 証拠階層で検証→仮説禁止→根本原因修正\n- architecture-patterns: EventBus/DI/Reactive/Service準拠チェック\n\nIMPORTANT: You must ACTUALLY MODIFY the code files, not just suggest improvements.\n\nRefactor constraints:\n- Tier: medium\n- Keep changes incremental and backward compatible.\n- Do NOT modify workflow files under .github/workflows/ or package-lock.json.\n- Keep PR size small:\n  - Max changed files (guard): 20\n  - Max changed lines (guard): 1200\n- If you must change runtime behavior, clearly explain why and add/update tests.\n\nTier guidelines:\n- small: touch 1-3 files, prefer local refactors (extract helpers/components, naming, reduce duplication).\n- medium: up to ~10 files within the same area, allowed to extract shared helpers/components inside that area.\n\nRefactoring priorities:\n1. Code duplication (DRY violations)\n2. Complex functions (>50 lines, high cyclomatic complexity)\n3. Poor naming (unclear variable/function names)\n4. Missing error handling\n5. Architecture pattern violations\n\nFor each file you review:\n1. Identify concrete refactoring opportunities\n2. IMPLEMENT the changes directly in the code\n3. Ensure backward compatibility\n4. Provide a summary of changes made\n\nOutput format:\n{\n  \"refactored\": true/false,\n  \"files_modified\": [\"path/to/file1.ts\", \"path/to/file2.ts\"],\n  \"changes_summary\": \"Description of refactoring applied\",\n  \"area\": \"Component/Module name (e.g., 'Authentication', 'API Handlers', 'UI Components')\"\n}\n\nUser Request:\n以下の領域のコードをリファクタリングしてください:\n\n領域: server/services\n\n制約:\n- Tier: medium\n- PRサイズガード: 変更ファイル数 <= 20, 差分行数 <= 1200\n- package-lock.json と .github/workflows/ 配下は変更しない\n- 既存挙動を壊さない（挙動変更が必要なら理由を明記し、テストを追加/更新する）\n- scopeを広げすぎない（smallは特に1-3ファイル中心）\n\nファイル:\n\n--- server/services/info-ssot-service.js (approx 1704 lines) ---\nimport { Pool } from 'pg';\nimport { ulid } from 'ulid';\nimport { logger } from '../utils/logger.js';\n\nconst ROLE_RANK = {\n    member: 1,\n    gm: 2,\n    ceo: 3\n};\n\nconst ROLE_VALUES = Object.keys(ROLE_RANK);\nconst SENSITIVITY_VALUES = ['internal', 'restricted', 'finance', 'hr', 'contract'];\nconst HIGH_SENSITIVITY_VALUES = ['finance', 'hr', 'contract'];\n\nexport class InfoSSOTService {\n    constructor() {\n        this.databaseUrl = process.env.INFO_SSOT_DATABASE_URL || process.env.INFO_SSOT_DB_URL || '';\n        this.pool = this.databaseUrl ? new Pool({ connectionString: this.databaseUrl }) : null;\n        if (!this.pool) {\n            logger.warn('InfoSSOTService disabled: INFO_SSOT_DATABASE_URL is not set');\n        }\n    }\n\n    assertReady() {\n        if (!this.pool) {\n            throw new Error('Info SSOT database is not configured');\n        }\n    }\n\n    generateId(prefix) {\n        return `${prefix}_${ulid()}`;\n    }\n\n    async upsertGraphEntity(client, { id, entityType, projectId, payload, roleMin, sensitivity }) {\n        await client.query(\n            `INSERT INTO graph_entities (\n                id,\n                entity_type,\n                project_id,\n                payload,\n                role_min,\n                sensitivity,\n                created_at,\n                updated_at\n            ) VALUES ($1,$2,$3,$4,$5,$6,NOW(),NOW())\n            ON CONFLICT (id)\n            DO UPDATE SET\n                entity_type = EXCLUDED.entity_type,\n                project_id = EXCLUDED.project_id,\n                payload = EXCLUDED.payload,\n                role_min = EXCLUDED.role_min,\n                sensitivity = EXCLUDED.sensitivity,\n                updated_at = NOW()`,\n            [\n                id,\n                entityType,\n                projectId,\n                JSON.stringify(payload || {}),\n                roleMin,\n                sensitivity\n            ]\n        );\n    }\n\n    async upsertGraphEdge(client, { fromId, toId, relType, projectId, payload, roleMin, sensitivity }) {\n        const edgeId = this.generateId('edg');\n        await client.query(\n            `INSERT INTO graph_edges (\n                id,\n                from_id,\n                to_id,\n                rel_type,\n                project_id,\n                payload,\n                role_min,\n                sensitivity,\n                created_at,\n                updated_at\n            ) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,NOW(),NOW())\n            ON CONFLICT (from_id, to_id, rel_type)\n            DO UPDATE SET\n                payload = EXCLUDED.payload,\n                role_min = EXCLUDED.role_min,\n                sensitivity = EXCLUDED.sensitivity,\n                updated_at = NOW()`,\n            [\n                edgeId,\n                fromId,\n                toId,\n                relType,\n                projectId,\n                JSON.stringify(payload || {}),\n                roleMin,\n                sensitivity\n            ]\n        );\n    }\n\n    normalizeRole(role) {\n        return typeof role === 'string' ? role.toLowerCase() : '';\n    }\n\n    normalizeSensitivity(value) {\n        return typeof value === 'string' ? value.toLowerCase() : '';\n    }\n\n    getRoleRank(role) {\n        return ROLE_RANK[this.normalizeRole(role)] || 0;\n    }\n\n    assertValidRole(role) {\n        if (!ROLE_VALUES.includes(this.normalizeRole(role))) {\n            throw new Error(`Invalid role: ${role}`);\n        }\n    }\n\n    assertValidSensitivity(value) {\n        if (!SENSITIVITY_VALUES.includes(this.normalizeSensitivity(value))) {\n            throw new Error(`Invalid sensitivity: ${value}`);\n        }\n    }\n\n    normalizeDecisionDomain(value) {\n        if (typeof value !== 'string') return '';\n        const trimmed = value.trim();\n        if (!trimmed) return '';\n        return trimmed.startsWith('decision:') ? trimmed.slice('decision:'.length) : trimmed;\n    }\n\n    resolveDecisionDomain(input) {\n        return this.normalizeDecisionDomain(\n            input.decisionDomain ||\n            input.decisionType ||\n            input.context?.decision_domain ||\n            input.context?.decision_type ||\n            ''\n        );\n    }\n\n    formatEntityLabel(record) {\n        const payload = record?.payload || {};\n        switch (record?.entity_type) {\n            case 'person':\n                return payload.name || record.id;\n            case 'project':\n                return payload.name || payload.code || record.id;\n            case 'decision':\n                return payload.title || record.id;\n            case 'raci_assignment':\n                return payload.role_code || record.id;\n            case 'ai_query':\n                return payload.intent || payload.query_type || record.id;\n            case 'ai_decision':\n                return payload.summary || record.id;\n            case 'glossary_term':\n                return payload.term || record.id;\n            case 'kpi':\n                return payload.metric_name || record.id;\n            case 'initiative':\n                return payload.title || record.id;\n            default:\n                return payload.title || payload.name || record.id;\n        }\n    }\n\n    summarizeEntities(records) {\n        return records.map(record => {\n            const payload = record?.payload || {};\n            switch (record?.entity_type) {\n                case 'decision':\n                    return `Decision: ${payload.title || record.id} (${payload.status || 'decided'})`;\n                case 'raci_assignment':\n                    return `RACI: ${payload.role_code || record.id} (${payload.authority_scope || ''})`;\n                case 'ai_query':\n                    return `AI Query: ${payload.intent || payload.query_type || record.id}`;\n                case 'ai_decision':\n                    return `AI Decision: ${payload.summary || record.id}`;\n                case 'person':\n                    return `Person: ${payload.name || record.id}`;\n                case 'project':\n                    return `Project: ${payload.name || payload.code || record.id}`;\n                case 'glossary_term':\n                    return `Glossary: ${payload.term || record.id} - ${payload.description || ''}`;\n                case 'kpi':\n                    return `KPI: ${payload.metric_name || record.id} (target: ${payload.target_value || 'N/A'}, current: ${payload.current_value || 'N/A'})`;\n                case 'initiative':\n                    return `Initiative: ${payload.title || record.id} (${payload.status || 'planned'})`;\n                default:\n                    return `${record.entity_type || 'entity'}: ${payload.title || payload.name || record.id}`;\n            }\n        });\n    }\n\n    async summarizeEdges(client, records) {\n        const idSet = new Set();\n        for (const record of records) {\n            if (record.from_id) idSet.add(record.from_id);\n            if (record.to_id) idSet.add(record.to_id);\n        }\n        const ids = Array.from(idSet);\n        const labelMap = new Map();\n        if (ids.length) {\n            const { rows } = await client.query(\n                'SELECT id, entity_type, payload FROM graph_entities WHERE id = ANY($1)',\n                [ids]\n            );\n            for (const row of rows) {\n                labelMap.set(row.id, this.formatEntityLabel(row));\n            }\n        }\n        const labelFor = (id) => labelMap.get(id) || id;\n        return records.map(record => {\n            const fromLabel = labelFor(record.from_id);\n            const toLabel = labelFor(record.to_id);\n            return `${fromLabel} -[${record.rel_type}]-> ${toLabel}`;\n        });\n    }\n\n    buildHumanReport({ seedId, projectCode, nodes, edges, summaryLines }) {\n        const byType = nodes.reduce((acc, node) => {\n            const type = node.entity_type || 'unknown';\n            if (!acc[type]) acc[type] = [];\n            acc[type].push(node);\n            return acc;\n        }, {});\n        const seedNode = nodes.find(node => node.id === seedId) || null;\n        const labelFor = (node) => (node ? this.formatEntityLabel(node) : seedId);\n\n        const decisionItems = (byType.decision || []).map(node => ({\n            id: node.id,\n            title: node.payload?.title || null,\n            status: node.payload?.status || null,\n            decided_at: node.payload?.decided_at || null\n        }));\n        const raciItems = (byType.raci_assignment || []).map(node => ({\n            id: node.id,\n            role_code: node.payload?.role_code || null,\n            authority_scope: node.payload?.authority_scope || null,\n            sensitivity_min: node.payload?.sensitivity_min || null\n        }));\n        const personItems = (byType.person || []).map(node => ({\n            id: node.id,\n            name: node.payload?.name || null\n        }));\n        const aiDecisionItems = (byType.ai_decision || []).map(node => ({\n            id: node.id,\n            summary: node.payload?.summary || null,\n            decision_type: node.payload?.decision_type || null,\n            decided_at: node.payload?.decided_at || null,\n            confidence: node.payload?.confidence || null\n        }));\n        const aiQueryItems = (byType.ai_query || []).map(node => ({\n            id: node.id,\n            intent: node.payload?.intent || null,\n            query_type: node.payload?.query_type || null,\n            result_count: node.payload?.result_count || null\n        }));\n        const projectItems = (byType.project || []).map(node => ({\n            id: node.id,\n            code: node.payload?.code || null,\n            name: node.payload?.name || null\n        }));\n        const glossaryItems = (byType.glossary_term || []).map(node => ({\n            id: node.id,\n            term: node.payload?.term || null,\n            reading: node.payload?.reading || null,\n            correct_form: node.payload?.correct_form || null,\n            incorrect_forms: node.payload?.incorrect_forms || null,\n            category: node.payload?.category || null,\n            description: node.payload?.description || null\n        }));\n        const kpiItems = (byType.kpi || []).map(node => ({\n            id: node.id,\n            metric_name: node.payload?.metric_name || null,\n            target_value: node.payload?.target_value || null,\n            current_value: node.payload?.current_value || null,\n            unit: node.payload?.unit || null,\n            period: node.payload?.period || null\n        }));\n        const initiativeItems = (byType.initiative || []).map(node => ({\n            id: node.id,\n            title: node.payload?.title || null,\n            status: node.payload?.status || null,\n            start_date: node.payload?.start_date || null,\n            end_date: node.payload?.end_date || null\n        }));\n\n        return {\n            header: {\n                seed_id: seedId,\n                seed_label: labelFor(seedNode),\n                seed_type: seedNode?.entity_type || null,\n                project_code: projectCode || null\n            },\n            meta: {\n                node_count: nodes.length,\n                edge_count: edges.length\n            },\n            sections: [\n                { title: 'Decisions', items: decisionItems },\n                { title: 'RACI', items: raciItems },\n                { title: 'People', items: personItems },\n                { title: 'AI Decisions', items: aiDecisionItems },\n                { title: 'AI Queries', items: aiQueryItems },\n                { title: 'Projects', items: projectItems },\n                { title: 'Glossary', items: glossaryItems },\n                { title: 'KPIs', items: kpiItems },\n                { title: 'Initiatives', items: initiativeItems }\n            ],\n            relations: summaryLines || []\n        };\n    }\n\n    assertWriteAccess(access, { projectCode, roleMin, sensitivity }) {\n        this.assertValidRole(access.role);\n        this.assertValidRole(roleMin);\n        this.assertValidSensitivity(sensitivity);\n\n        if (!acce\n\n\n--- server/services/session-manager.js (approx 1375 lines) ---\n/**\n * SessionManager\n * セッション管理とttyd/tmuxプロセス管理を担当\n */\nimport { spawn, execSync } from 'child_process';\nimport fs from 'fs';\nimport net from 'net';\nimport path from 'path';\nimport { TerminalOutputParser } from './terminal-output-parser.js';\n\nexport class SessionManager {\n    /**\n     * @param {Object} options - 設定オプション\n     * @param {string} options.serverDir - server.jsのディレクトリ（__dirname）\n     * @param {Function} options.execPromise - util.promisify(exec)\n     * @param {Object} options.stateStore - StateStoreインスタンス\n     * @param {Object} options.worktreeService - WorktreeServiceインスタンス（Phase 2）\n     * @param {number|string} [options.uiPort] - UIサーバーのポート\n     */\n    constructor({ serverDir, execPromise, stateStore, worktreeService, uiPort }) {\n        this.serverDir = serverDir;\n        this.execPromise = execPromise;\n        this.stateStore = stateStore;\n        this.worktreeService = worktreeService;  // Phase 2: Worktree削除用\n        this.uiPort = uiPort;\n\n        // セッション状態\n        this.activeSessions = new Map(); // sessionId -> { port, process }\n        this.hookStatus = new Map(); // sessionId -> { status: 'working'|'done', timestamp }\n        // ポート範囲を40000番台に設定（UIの31013/31014帯との競合回避）\n        this.nextPort = 40000;\n\n        // 起動準備完了フラグ\n        this._isReady = false;\n        this._readyResolver = null;\n        this._readyPromise = new Promise((resolve) => {\n            this._readyResolver = resolve;\n        });\n\n        // ターミナル出力パーサー\n        this.outputParser = new TerminalOutputParser();\n\n        // 許可されたキー\n        this.ALLOWED_KEYS = ['M-Enter', 'C-c', 'C-d', 'C-l', 'C-u', 'Enter', 'Escape', 'Up', 'Down', 'Tab', 'S-Tab', 'BTab'];\n    }\n\n    /**\n     * 永続化された状態からhookStatusを復元\n     */\n    async restoreHookStatus() {\n        const state = this.stateStore.get();\n        if (state.sessions) {\n            state.sessions.forEach(session => {\n                if (session.hookStatus) {\n                    this.hookStatus.set(session.id, session.hookStatus);\n                }\n            });\n        }\n    }\n\n    /**\n     * Phase 3: activeセッションを復元\n     * サーバー起動時にstate.jsonからintendedState === 'active'のセッションを復元し、\n     * 既存のttydプロセスと紐付ける。\n     *\n     * 改善: state.jsonのttydProcess情報を優先使用\n     * 1. ttydProcess情報がある場合 → プロセス存在確認 → activeSessionsに登録\n     * 2. ttydProcess情報がない場合 → ps auxで検索（後方互換性）\n     * 3. どちらでも見つからない場合 → 新規起動\n     */\n    async restoreActiveSessions() {\n        try {\n            console.log('[restoreActiveSessions] Restoring active sessions from state.json...');\n\n            const state = this.stateStore.get();\n            const sessions = state.sessions || [];\n            if (sessions.length === 0) {\n                console.log('[restoreActiveSessions] No sessions in state.json');\n                return;\n            }\n\n            // intendedState === 'active' のセッションを抽出\n            const activeSessions = sessions.filter(s => s.intendedState === 'active');\n            console.log(`[restoreActiveSessions] Found ${activeSessions.length} active session(s) in state.json`);\n\n            if (activeSessions.length === 0) {\n                return;\n            }\n\n            // Collect tmux sessions once\n            const { stdout: tmuxOut } = await this.execPromise(\n                'tmux list-sessions -F \"#{session_name}\" 2>/dev/null || echo \"\"'\n            ).catch(() => ({ stdout: '' }));\n            const tmuxSessions = new Set(tmuxOut.trim().split('\\n').filter(Boolean));\n\n            // Collect ttyd processes once\n            const { stdout: psOut } = await this.execPromise('ps aux | grep ttyd | grep -v grep').catch(() => ({ stdout: '' }));\n            const ttydLines = psOut.trim() ? psOut.trim().split('\\n') : [];\n\n            const ttydProcsBySessionId = new Map();\n            for (const line of ttydLines) {\n                const parts = line.trim().split(/\\s+/);\n                const pid = parseInt(parts[1], 10);\n                if (!Number.isFinite(pid)) continue;\n\n                const sessionMatch = line.match(/-b\\s+\\/console\\/(session-\\d+)/);\n                const sessionId = sessionMatch ? sessionMatch[1] : null;\n                if (!sessionId) continue;\n\n                const portMatch = line.match(/-p\\s+(\\d+)/);\n                const port = portMatch ? parseInt(portMatch[1], 10) : null;\n                if (!Number.isFinite(port)) continue;\n\n                const list = ttydProcsBySessionId.get(sessionId) || [];\n                list.push({ pid, port, line });\n                ttydProcsBySessionId.set(sessionId, list);\n            }\n\n            const pauseSessionIds = new Set();\n\n            for (const session of activeSessions) {\n                const sessionId = session.id;\n                const engine = session.engine || 'claude';\n                const initialCommand = session.initialCommand || '';\n                const cwd = session.path || (session.worktree && session.worktree.path);\n\n                const hasTmux = tmuxSessions.has(sessionId);\n                const candidates = ttydProcsBySessionId.get(sessionId) || [];\n\n                // If tmux is missing, don't auto-recreate. Pause + kill stray ttyd (prevents wrong log linkage).\n                if (!hasTmux) {\n                    if (candidates.length > 0) {\n                        console.warn(`[restoreActiveSessions] TMUX missing for ${sessionId}. Killing ${candidates.length} ttyd process(es) and pausing session.`);\n                        for (const proc of candidates) {\n                            await this.execPromise(`kill ${proc.pid}`).catch(() => {});\n                        }\n                    } else {\n                        console.warn(`[restoreActiveSessions] TMUX missing for ${sessionId}. Pausing session.`);\n                    }\n                    pauseSessionIds.add(sessionId);\n                    this.activeSessions.delete(sessionId);\n                    continue;\n                }\n\n                // Prefer persisted pid if it's still running.\n                const persistedPid = session?.ttydProcess?.pid;\n                const persistedPort = session?.ttydProcess?.port;\n\n                let keep = null;\n                if (Number.isFinite(persistedPid) && this._isProcessRunning(persistedPid)) {\n                    const port = Number.isFinite(persistedPort)\n                        ? persistedPort\n                        : candidates.find(p => p.pid === persistedPid)?.port;\n                    if (Number.isFinite(port)) {\n                        keep = { pid: persistedPid, port };\n                    }\n                }\n\n                // Otherwise, adopt from ps aux.\n                if (!keep && candidates.length > 0) {\n                    const running = candidates.filter(p => this._isProcessRunning(p.pid));\n                    const pool = running.length > 0 ? running : candidates;\n                    const chosen = pool.sort((a, b) => b.pid - a.pid)[0];\n                    keep = { pid: chosen.pid, port: chosen.port };\n                }\n\n                if (keep && Number.isFinite(keep.pid) && Number.isFinite(keep.port)) {\n                    this.activeSessions.set(sessionId, {\n                        port: keep.port,\n                        pid: keep.pid,\n                        process: null\n                    });\n\n                    // Kill duplicates (best-effort)\n                    for (const proc of candidates) {\n                        if (proc.pid === keep.pid) continue;\n                        console.warn(`[restoreActiveSessions] Duplicate ttyd for ${sessionId}: killing pid ${proc.pid} (keeping ${keep.pid})`);\n                        await this.execPromise(`kill ${proc.pid}`).catch(() => {});\n                    }\n\n                    // Sync persisted ttydProcess when needed\n                    if (session?.ttydProcess?.pid !== keep.pid || session?.ttydProcess?.port !== keep.port) {\n                        await this._saveTtydProcessInfo(sessionId, { port: keep.port, pid: keep.pid, engine });\n                    }\n\n                    console.log(`[restoreActiveSessions] Restored session ${sessionId}: PID ${keep.pid}, Port ${keep.port}`);\n                    continue;\n                }\n\n                // No running ttyd found: clear stale info then start a new ttyd attached to existing tmux.\n                if (session.ttydProcess) {\n                    await this._clearTtydProcessInfo(sessionId);\n                }\n\n                try {\n                    // Use persisted port for reconnection stability (UI URLs stay valid)\n                    const preferredPort = session?.ttydProcess?.port;\n                    console.log(`[restoreActiveSessions] Reconnecting ttyd for ${sessionId} (preferredPort: ${preferredPort}, engine: ${engine})`);\n\n                    await this._restartTtydForExistingTmux(sessionId, preferredPort, engine);\n                    console.log(`[restoreActiveSessions] Successfully reconnected ttyd for ${sessionId}`);\n                } catch (err) {\n                    console.error(`[restoreActiveSessions] Failed to reconnect ttyd for ${sessionId}:`, err);\n                }\n            }\n\n            if (pauseSessionIds.size > 0) {\n                const now = new Date().toISOString();\n                const currentState = this.stateStore.get();\n                const updatedSessions = (currentState.sessions || []).map(session => {\n                    if (!pauseSessionIds.has(session.id)) return session;\n                    return {\n                        ...session,\n                        intendedState: 'paused',\n                        pausedAt: now,\n                        tmuxMissingAt: now,\n                        ttydProcess: null,\n                        updatedAt: now\n                    };\n                });\n                await this.stateStore.update({ ...currentState, sessions: updatedSessions });\n                console.warn(`[restoreActiveSessions] Paused ${pauseSessionIds.size} session(s) with missing TMUX`);\n            }\n\n            console.log(`[restoreActiveSessions] Total restored/started: ${this.activeSessions.size} session(s)`);\n\n            // Update nextPort to avoid port conflicts with restored sessions\n            // 既存セッションがUIポート帯でも、新規セッションは40000番台から開始\n            const ports = Array.from(this.activeSessions.values())\n                .map(s => s.port)\n                .filter(p => Number.isFinite(p));\n\n            if (ports.length > 0) {\n                const maxPort = Math.max(40000, ...ports);\n                this.nextPort = maxPort + 1;\n                console.log(`[restoreActiveSessions] Updated nextPort to ${this.nextPort} (max existing port: ${maxPort})`);\n            }\n\n            // Best-effort: orphan/duplicate cleanup\n            await this.cleanupOrphans();\n        } catch (err) {\n            console.error('[restoreActiveSessions] Error:', err);\n        }\n    }\n\n    /**\n     * 孤立したttydプロセスをクリーンアップ\n     *\n     * BUG FIX: 以前は`pkill ttyd`で全プロセスを殺していたが、\n     * これはactiveセッションのttydも殺してしまう。\n     *\n     * 修正後: activeSessionsに登録されていないttydプロセスのみ殺す\n     */\n    async cleanupOrphans() {\n        try {\n            console.log('[cleanupOrphans] Checking for orphaned/duplicate ttyd processes...');\n\n            // 1. 全てのttydプロセスを取得\n            const { stdout } = await this.execPromise('ps aux | grep ttyd | grep -v grep').catch(() => ({ stdout: '' }));\n            if (!stdout.trim()) {\n                console.log('[cleanupOrphans] No ttyd processes found');\n                return;\n            }\n\n            const lines = stdout.trim().split('\\n');\n            console.log(`[cleanupOrphans] Found ${lines.length} ttyd process(es)`);\n\n            // 2. 保護対象: state.json の intendedState === 'active' または 'paused'\n            const state = this.stateStore.get();\n            const protectedSessionIds = new Set(\n                (state.sessions || [])\n                    .filter(s => s.intendedState === 'active' || s.intendedState === 'paused')\n                    .map(s => s.id)\n            );\n            console.log(`[cleanupOrp\n\n\n--- server/services/nocodb-service.js (approx 838 lines) ---\nimport { logger } from '../utils/logger.js';\n\n/**\n * NocoDB Service\n * 各プロジェクトのNocoDB Base からタスク・マイルストーンを取得\n */\nexport class NocoDBService {\n    constructor() {\n        this.baseUrl = process.env.NOCODB_URL || 'https://noco.unson.jp';\n        this.apiToken = process.env.NOCODB_TOKEN;\n        this.timeout = 15000; // 15秒\n        this.maxRetries = 3;  // 最大リトライ回数\n        this._tableIdCache = new Map(); // baseId:tableName -> tableId キャッシュ\n    }\n\n    /**\n     * fetch with retry logic (exponential backoff)\n     * @private\n     * @param {string} url - Request URL\n     * @param {Object} options - Fetch options\n     * @param {number} retries - Current retry count\n     * @returns {Promise<Response>} Fetch response\n     */\n    async _fetchWithRetry(url, options, retries = 0) {\n        try {\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n            const response = await fetch(url, {\n                ...options,\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n            return response;\n        } catch (error) {\n            // Retry only for timeout errors (AbortError)\n            if (retries < this.maxRetries && error.name === 'AbortError') {\n                const delay = Math.pow(2, retries) * 1000; // 1s, 2s, 4s\n                logger.warn(`Request timeout. Retrying in ${delay}ms... (${retries + 1}/${this.maxRetries})`, { url });\n                await new Promise(resolve => setTimeout(resolve, delay));\n                return this._fetchWithRetry(url, options, retries + 1);\n            }\n            throw error;\n        }\n    }\n\n    /**\n     * 指定プロジェクトの統計を取得（タスク + マイルストーン）\n     * @param {string} projectId - NocoDB Project ID\n     * @returns {Promise<Object>} プロジェクト統計\n     */\n    async getProjectStats(projectId) {\n        try {\n            // タスクとマイルストーンを並列取得\n            const [tasks, milestones] = await Promise.all([\n                this._fetchRecords(projectId, 'タスク'),\n                this._fetchRecords(projectId, 'マイルストーン')\n            ]);\n\n            // タスク統計\n            const taskStats = this._calculateTaskStats(tasks);\n\n            // マイルストーン統計\n            const milestoneStats = this._calculateMilestoneStats(milestones);\n\n            return {\n                ...taskStats,\n                ...milestoneStats\n            };\n        } catch (error) {\n            logger.error(`Failed to get project stats for project ${projectId}`, { error });\n            return this._getDefaultStats();\n        }\n    }\n\n    /**\n     * NocoDBからレコード取得（v2 API使用）\n     * @param {string} baseId - NocoDB Base ID\n     * @param {string} tableName - テーブル名\n     * @returns {Promise<Array>} レコード一覧\n     */\n    async _fetchRecords(baseId, tableName) {\n        // テーブル名からtableIdを取得\n        const tableId = await this._getTableId(baseId, tableName);\n        if (!tableId) {\n            logger.warn(`Table not found: ${tableName} in base ${baseId}`);\n            return [];\n        }\n\n        // NocoDB v2 API: /api/v2/tables/{tableId}/records\n        const url = `${this.baseUrl}/api/v2/tables/${tableId}/records`;\n\n        const response = await this._fetchWithRetry(url, {\n            headers: {\n                'xc-token': this.apiToken\n            }\n        });\n\n        if (!response.ok) {\n            throw new Error(`NocoDB API failed: ${response.status}`);\n        }\n\n        const data = await response.json();\n        return data.list || [];\n    }\n\n    /**\n     * テーブル名からtableIdを取得（キャッシュ付き）\n     * @param {string} baseId - NocoDB Base ID\n     * @param {string} tableName - テーブル名\n     * @returns {Promise<string|null>} tableId\n     */\n    async _getTableId(baseId, tableName) {\n        const cacheKey = `${baseId}:${tableName}`;\n\n        // キャッシュにあればそれを返す\n        if (this._tableIdCache.has(cacheKey)) {\n            return this._tableIdCache.get(cacheKey);\n        }\n\n        try {\n            // v2 API: テーブル一覧取得\n            const url = `${this.baseUrl}/api/v2/meta/bases/${baseId}/tables`;\n            const response = await this._fetchWithRetry(url, {\n                headers: {\n                    'xc-token': this.apiToken\n                }\n            });\n\n            if (!response.ok) {\n                throw new Error(`NocoDB API failed: ${response.status}`);\n            }\n\n            const data = await response.json();\n            const tables = data.list || [];\n\n            // 全テーブルをキャッシュ\n            for (const table of tables) {\n                this._tableIdCache.set(`${baseId}:${table.title}`, table.id);\n            }\n\n            return this._tableIdCache.get(cacheKey) || null;\n        } catch (error) {\n            logger.error(`Failed to get table ID for ${tableName} in base ${baseId}`, { error });\n            return null;\n        }\n    }\n\n    /**\n     * タスク統計計算\n     * @param {Array} tasks - タスク一覧\n     * @returns {Object} タスク統計（フラット構造）\n     */\n    _calculateTaskStats(tasks) {\n        const total = tasks.length;\n        const completed = tasks.filter(t => t.ステータス === '完了').length;\n        const inProgress = tasks.filter(t => t.ステータス === '進行中').length;\n        const pending = tasks.filter(t => t.ステータス === '未着手').length;\n        const blocked = tasks.filter(t => t.ステータス === 'ブロック').length;\n\n        // 期限超過タスク\n        const now = new Date();\n        const overdue = tasks.filter(t => {\n            if (t.ステータス === '完了') return false;\n            if (!t.期限) return false;\n            return new Date(t.期限) < now;\n        }).length;\n\n        const completionRate = total > 0 ? Math.round((completed / total) * 100) : 100;\n\n        return {\n            total,\n            completed,\n            inProgress,\n            pending,\n            blocked,\n            overdue,\n            completionRate\n        };\n    }\n\n    /**\n     * マイルストーン統計計算\n     * @param {Array} milestones - マイルストーン一覧\n     * @returns {Object} マイルストーン統計（フラット構造）\n     */\n    _calculateMilestoneStats(milestones) {\n        if (milestones.length === 0) {\n            return {\n                averageProgress: 0\n            };\n        }\n\n        // 進捗率の平均（nullを除外）\n        const progressValues = milestones\n            .map(m => m.進捗率)\n            .filter(p => p !== null && p !== undefined);\n\n        const averageProgress = progressValues.length > 0\n            ? Math.round(progressValues.reduce((sum, p) => sum + p, 0) / progressValues.length)\n            : 0;\n\n        return {\n            averageProgress\n        };\n    }\n\n    /**\n     * 複数プロジェクトの統計を並列取得\n     * @param {Array} projects - プロジェクト一覧（{ id, project_id }）\n     * @returns {Promise<Array>} プロジェクト統計一覧\n     */\n    async getAllProjectStats(projects) {\n        const results = await Promise.all(\n            projects.map(async (project) => {\n                const stats = await this.getProjectStats(project.project_id);\n                return {\n                    projectId: project.id,\n                    ...stats\n                };\n            })\n        );\n\n        return results;\n    }\n\n    /**\n     * Critical Alerts取得（ブロッカー + 期限超過タスク）\n     * @param {Array} projects - プロジェクト一覧（{ id, project_id }）\n     * @returns {Promise<Object>} Critical Alerts（alerts, total_critical, total_warning）\n     */\n    async getCriticalAlerts(projects) {\n        try {\n            const alerts = [];\n\n            // 全プロジェクトのタスクを並列取得\n            const projectTasks = await Promise.all(\n                projects.map(async (project) => {\n                    try {\n                        const tasks = await this._fetchRecords(project.project_id, 'タスク');\n                        return { projectId: project.id, tasks };\n                    } catch (error) {\n                        logger.error(`Failed to fetch tasks for project ${project.id}`, { error });\n                        return { projectId: project.id, tasks: [] };\n                    }\n                })\n            );\n\n            const now = new Date();\n\n            // ブロッカータスクと期限超過タスクを抽出\n            for (const { projectId, tasks } of projectTasks) {\n                for (const task of tasks) {\n                    // ブロッカータスク\n                    if (task.ステータス === 'ブロック') {\n                        const createdDate = task.作成日 ? new Date(task.作成日) : now;\n                        const daysBlocked = Math.floor((now - createdDate) / (1000 * 60 * 60 * 24));\n\n                        alerts.push({\n                            type: 'blocker',\n                            project: projectId,\n                            task: task.タイトル || task.タスク名 || 'Untitled',\n                            owner: task.担当者 || 'Unassigned',\n                            days_blocked: daysBlocked,\n                            severity: 'critical'\n                        });\n                    }\n\n                    // 期限超過タスク（完了以外）\n                    if (task.ステータス !== '完了' && task.期限) {\n                        const deadline = new Date(task.期限);\n                        if (deadline < now) {\n                            const daysOverdue = Math.floor((now - deadline) / (1000 * 60 * 60 * 24));\n\n                            alerts.push({\n                                type: 'overdue',\n                                project: projectId,\n                                task: task.タイトル || task.タスク名 || 'Untitled',\n                                owner: task.担当者 || 'Unassigned',\n                                days_overdue: daysOverdue,\n                                deadline: task.期限,\n                                severity: 'warning'\n                            });\n                        }\n                    }\n                }\n            }\n\n            // Critical/Warning数を集計\n            const total_critical = alerts.filter(a => a.severity === 'critical').length;\n            const total_warning = alerts.filter(a => a.severity === 'warning').length;\n\n            return {\n                alerts,\n                total_critical,\n                total_warning\n            };\n        } catch (error) {\n            logger.error('Failed to get critical alerts', { error });\n            return {\n                alerts: [],\n                total_critical: 0,\n                total_warning: 0\n            };\n        }\n    }\n\n    /**\n     * デフォルト統計値（エラー時のフォールバック）\n     * @returns {Object} デフォルト統計（フラット構造）\n     */\n    _getDefaultStats() {\n        return {\n            total: 0,\n            completed: 0,\n            inProgress: 0,\n            pending: 0,\n            blocked: 0,\n            overdue: 0,\n            completionRate: 0,\n            averageProgress: 0\n        };\n    }\n\n    /**\n     * プロジェクト健全性スナップショットを履歴テーブルに挿入\n     * @param {Object} data - スナップショットデータ\n     * @param {string} data.project_id - プロジェクトID\n     * @param {string} data.snapshot_date - スナップショット日付（YYYY-MM-DD）\n     * @param {number} data.total_tasks - タスク総数\n     * @param {number} data.completed_tasks - 完了タスク数\n     * @param {number} data.overdue_tasks - 期限超過タスク数\n     * @param {number} data.blocked_tasks - ブロックタスク数\n     * @param {number} data.completion_rate - 完了率（%）\n     * @param {number} data.milestone_progress - マイルストーン進捗率（%）\n     * @param {number} data.health_score - 健全性スコア（0-100）\n     * @returns {Promise<Object>} 挿入結果\n     */\n    async insertSnapshot(data) {\n        try {\n            // NocoDB v1 API: /api/v1/db/data/noco/{projectId}/{tableName}\n            // Note: Table name must be created manually in NocoDB UI first\n            // Table: プロジェクト健全性履歴\n            // UNIQUE constraint: project_id + snapshot_date\n            const tableName = 'プロジェクト健全性履歴';\n            const url = `${this.baseUrl}/api/v1/db/data/noco/brainbase/${encodeURIComponent(tableName)}`;\n\n            const response = await this._fetchWithRetry(url, {\n                method: 'POST',\n                headers: {\n                    'xc-token': this.apiToken,\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    project_id: data.project_id,\n                    snapshot_date: data.snapshot_date,\n \n\n\n--- server/services/auth-service.js (approx 779 lines) ---\nimport crypto from 'crypto';\nimport { Pool } from 'pg';\nimport { ulid } from 'ulid';\nimport jwt from 'jsonwebtoken';\nimport { logger } from '../utils/logger.js';\n\nconst DEFAULT_SCOPES = 'openid profile email';\nconst DEFAULT_CLEARANCE = ['internal', 'restricted'];\nconst FULL_CLEARANCE = ['internal', 'restricted', 'finance', 'hr', 'contract'];\n\nconst ROLE_RANK = {\n    member: 1,\n    gm: 2,\n    ceo: 3\n};\n\nexport class AuthService {\n    constructor() {\n        this.databaseUrl = process.env.INFO_SSOT_DATABASE_URL || process.env.INFO_SSOT_DB_URL || '';\n        this.pool = this.databaseUrl ? new Pool({ connectionString: this.databaseUrl }) : null;\n        this.jwtSecret = process.env.BRAINBASE_JWT_SECRET || '';\n        this.refreshSecret = process.env.BRAINBASE_REFRESH_SECRET || this.jwtSecret || '';\n        this.refreshTtlSeconds = Number(process.env.BRAINBASE_REFRESH_TTL_SECONDS || 60 * 60 * 24 * 30);\n        this.stateSecret = process.env.BRAINBASE_AUTH_STATE_SECRET || this.jwtSecret || '';\n\n        this.slackClientId = process.env.SLACK_CLIENT_ID || '';\n        this.slackClientSecret = process.env.SLACK_CLIENT_SECRET || '';\n        this.slackRedirectUri = process.env.SLACK_REDIRECT_URI || '';\n        this.slackScopes = process.env.SLACK_AUTH_SCOPES;\n        if (this.slackScopes === undefined || this.slackScopes === null) {\n            this.slackScopes = DEFAULT_SCOPES;\n        }\n        this.slackUserScopes = process.env.SLACK_AUTH_USER_SCOPES || '';\n        this.slackMode = (process.env.SLACK_AUTH_MODE || 'oidc').toLowerCase();\n\n        this.authorizeUrl = process.env.SLACK_AUTH_AUTHORIZE_URL\n            || (this.slackMode === 'oauth'\n                ? 'https://slack.com/oauth/v2/authorize'\n                : 'https://slack.com/openid/connect/authorize');\n        this.tokenUrl = process.env.SLACK_AUTH_TOKEN_URL\n            || (this.slackMode === 'oauth'\n                ? 'https://slack.com/api/oauth.v2.access'\n                : 'https://slack.com/api/openid.connect.token');\n        this.userInfoUrl = process.env.SLACK_AUTH_USERINFO_URL\n            || 'https://slack.com/api/openid.connect.userInfo';\n\n        this.stateStore = new Map();\n        this.stateTtlMs = 10 * 60 * 1000;\n        this.codeChallengeStore = new Map(); // code → { codeChallenge, createdAt }\n\n        // Device Code Flow stores\n        this.deviceCodeStore = new Map(); // device_code → { codeVerifier, userCode, createdAt, status, slackUserId, slackWorkspaceId }\n        this.userCodeStore = new Map(); // user_code → device_code\n        this.deviceCodeTtlMs = 10 * 60 * 1000; // 10 minutes (RFC 8628 recommends 5-15 minutes)\n        this.deviceCodePollingInterval = 5; // 5 seconds\n\n        // Device Code cleanup interval (every 1 minute)\n        setInterval(() => this.cleanupExpiredDeviceCodes(), 60 * 1000);\n    }\n\n    assertReady() {\n        if (!this.pool) {\n            throw new Error('Info SSOT database is not configured');\n        }\n        if (!this.jwtSecret) {\n            throw new Error('BRAINBASE_JWT_SECRET is not set');\n        }\n        if (!this.slackClientId || !this.slackClientSecret || !this.slackRedirectUri) {\n            throw new Error('Slack OAuth configuration is missing');\n        }\n    }\n\n    generateId(prefix) {\n        return `${prefix}_${ulid()}`;\n    }\n\n    createState({ origin, codeChallenge } = {}) {\n        if (this.stateSecret) {\n            return this.createSignedState({ origin, codeChallenge });\n        }\n        const state = crypto.randomBytes(16).toString('hex');\n        this.stateStore.set(state, {\n            createdAt: Date.now(),\n            origin: typeof origin === 'string' ? origin : null,\n            codeChallenge: typeof codeChallenge === 'string' ? codeChallenge : null\n        });\n        return state;\n    }\n\n    consumeState(state) {\n        if (this.stateSecret) {\n            return this.consumeSignedState(state);\n        }\n        const record = this.stateStore.get(state);\n        this.stateStore.delete(state);\n        if (!record || !record.createdAt) {\n            return { ok: false, origin: null, codeChallenge: null };\n        }\n        const ok = Date.now() - record.createdAt < this.stateTtlMs;\n        return { ok, origin: record.origin || null, codeChallenge: record.codeChallenge || null };\n    }\n\n    createSignedState({ origin, codeChallenge } = {}) {\n        const ts = Date.now();\n        const nonce = crypto.randomBytes(16).toString('hex');\n        const originValue = typeof origin === 'string' && origin.length > 0\n            ? Buffer.from(origin, 'utf8').toString('base64url')\n            : '';\n        const codeChallengeValue = typeof codeChallenge === 'string' && codeChallenge.length > 0\n            ? Buffer.from(codeChallenge, 'utf8').toString('base64url')\n            : '';\n\n        let payload = `${ts}.${nonce}`;\n        if (originValue) payload += `.${originValue}`;\n        if (codeChallengeValue) payload += `.${codeChallengeValue}`;\n\n        const signature = crypto\n            .createHmac('sha256', this.stateSecret)\n            .update(payload)\n            .digest('hex');\n        return `${payload}.${signature}`;\n    }\n\n    consumeSignedState(state) {\n        if (typeof state !== 'string') return { ok: false, origin: null, codeChallenge: null };\n        const parts = state.split('.');\n        // 3: ts.nonce.signature\n        // 4: ts.nonce.origin.signature\n        // 5: ts.nonce.origin.codeChallenge.signature\n        if (parts.length < 3 || parts.length > 5) {\n            return { ok: false, origin: null, codeChallenge: null };\n        }\n\n        const signature = parts[parts.length - 1];\n        const tsRaw = parts[0];\n        const nonce = parts[1];\n        const originEncoded = parts.length >= 4 ? parts[2] : '';\n        const codeChallengeEncoded = parts.length === 5 ? parts[3] : '';\n\n        if (!tsRaw || !nonce || !signature) {\n            return { ok: false, origin: null, codeChallenge: null };\n        }\n\n        // Reconstruct payload\n        let payload = `${tsRaw}.${nonce}`;\n        if (originEncoded) payload += `.${originEncoded}`;\n        if (codeChallengeEncoded) payload += `.${codeChallengeEncoded}`;\n\n        const expected = crypto\n            .createHmac('sha256', this.stateSecret)\n            .update(payload)\n            .digest('hex');\n        try {\n            const sigBuf = Buffer.from(signature, 'hex');\n            const expBuf = Buffer.from(expected, 'hex');\n            if (sigBuf.length !== expBuf.length) {\n                return { ok: false, origin: null, codeChallenge: null };\n            }\n            if (!crypto.timingSafeEqual(sigBuf, expBuf)) {\n                return { ok: false, origin: null, codeChallenge: null };\n            }\n        } catch {\n            return { ok: false, origin: null, codeChallenge: null };\n        }\n        const ts = Number(tsRaw);\n        if (!Number.isFinite(ts)) return { ok: false, origin: null, codeChallenge: null };\n        const ageMs = Math.abs(Date.now() - ts);\n        if (ageMs >= this.stateTtlMs) {\n            return { ok: false, origin: null, codeChallenge: null };\n        }\n\n        let origin = null;\n        if (originEncoded) {\n            try {\n                origin = Buffer.from(originEncoded, 'base64url').toString('utf8');\n            } catch {\n                origin = null;\n            }\n        }\n\n        let codeChallenge = null;\n        if (codeChallengeEncoded) {\n            try {\n                codeChallenge = Buffer.from(codeChallengeEncoded, 'base64url').toString('utf8');\n            } catch {\n                codeChallenge = null;\n            }\n        }\n\n        return { ok: true, origin, codeChallenge };\n    }\n\n    buildAuthorizeUrl(state) {\n        const url = new URL(this.authorizeUrl);\n        url.searchParams.set('client_id', this.slackClientId);\n        url.searchParams.set('redirect_uri', this.slackRedirectUri);\n        url.searchParams.set('state', state);\n        if (this.slackScopes !== undefined && this.slackScopes !== null) {\n            url.searchParams.set('scope', this.slackScopes);\n        }\n        if (this.slackMode === 'oauth' && this.slackUserScopes) {\n            url.searchParams.set('user_scope', this.slackUserScopes);\n        }\n        url.searchParams.set('response_type', 'code');\n        return url.toString();\n    }\n\n    async exchangeCode(code) {\n        const body = new URLSearchParams({\n            client_id: this.slackClientId,\n            client_secret: this.slackClientSecret,\n            redirect_uri: this.slackRedirectUri,\n            code\n        });\n        if (this.slackMode !== 'oauth') {\n            body.set('grant_type', 'authorization_code');\n        }\n        const res = await fetch(this.tokenUrl, {\n            method: 'POST',\n            headers: { 'content-type': 'application/x-www-form-urlencoded' },\n            body\n        });\n        const text = await res.text();\n        if (!res.ok) {\n            throw new Error(`Slack token exchange failed: ${res.status} ${text}`);\n        }\n        const data = text ? JSON.parse(text) : {};\n        if (data.ok === false) {\n            throw new Error(`Slack token exchange failed: ${data.error || 'unknown_error'}`);\n        }\n        return data;\n    }\n\n    async fetchUserInfo(accessToken) {\n        const res = await fetch(this.userInfoUrl, {\n            method: 'GET',\n            headers: { Authorization: `Bearer ${accessToken}` }\n        });\n        const text = await res.text();\n        if (!res.ok) {\n            throw new Error(`Slack userinfo failed: ${res.status} ${text}`);\n        }\n        const data = text ? JSON.parse(text) : {};\n        if (data.ok === false) {\n            throw new Error(`Slack userinfo failed: ${data.error || 'unknown_error'}`);\n        }\n        return data;\n    }\n\n    resolveSlackIdentity(tokenPayload, userInfo) {\n        const fromTokenUser = tokenPayload?.authed_user?.id || tokenPayload?.user?.id || tokenPayload?.user_id || tokenPayload?.sub || null;\n        const fromTokenTeam = tokenPayload?.team?.id || tokenPayload?.team_id || tokenPayload?.enterprise_id || tokenPayload?.workspace_id || null;\n\n        const userIdCandidates = [\n            userInfo?.user_id,\n            userInfo?.sub,\n            userInfo?.id,\n            userInfo?.['https://slack.com/user_id'],\n            fromTokenUser\n        ].filter(Boolean);\n\n        const teamIdCandidates = [\n            userInfo?.team_id,\n            userInfo?.['https://slack.com/team_id'],\n            userInfo?.team?.id,\n            fromTokenTeam\n        ].filter(Boolean);\n\n        return {\n            slackUserId: userIdCandidates[0] || null,\n            slackWorkspaceId: teamIdCandidates[0] || null\n        };\n    }\n\n    async findGrant({ slackUserId, slackWorkspaceId }) {\n        const client = await this.pool.connect();\n        try {\n            const { rows } = await client.query(\n                `SELECT *\n                 FROM auth_grants\n                 WHERE slack_user_id = $1\n                   AND slack_workspace_id = $2\n                   AND active = true\n                 LIMIT 1`,\n                [slackUserId, slackWorkspaceId]\n            );\n            return rows[0] || null;\n        } finally {\n            client.release();\n        }\n    }\n\n    /**\n     * Find user by Slack user ID (Permission System Phase 1)\n     * @param {string} slackUserId - Slack user ID (e.g., 'U07LNUP582X')\n     * @returns {Promise<Object|null>} - User object or null if not found\n     */\n    async findUserBySlackId(slackUserId) {\n        if (!this.pool) {\n            throw new Error('Database pool is not configured');\n        }\n\n        const client = await this.pool.connect();\n        try {\n            const { rows } = await client.query(\n                `SELECT *\n                 FROM users\n                 WHERE slack_user_id = $1\n                   AND status = 'active'\n                 LIMIT 1`,\n                [slackUserId]\n            );\n            return rows[0] || null;\n        } finally {\n            cl\n\n\n--- server/services/worktree-service.js (approx 455 lines) ---\n/**\n * WorktreeService\n * Jujutsu workspace操作を管理するサービス（Git worktreeから移行）\n *\n * 変更点:\n * - Git worktree → Jujutsu workspace\n * - jj workspace add --name <name> <path>\n * - jj git push --bookmark <name>\n * - jj workspace forget <name> + 物理ディレクトリ削除\n */\nimport { promises as fs } from 'fs';\nimport path from 'path';\n\nexport class WorktreeService {\n    /**\n     * @param {string} worktreesDir - workspaces保存ディレクトリ\n     * @param {string} canonicalRoot - メインリポジトリのパス（listWorktrees()で使用）\n     * @param {Function} execPromise - util.promisify(exec)\n     */\n    constructor(worktreesDir, canonicalRoot, execPromise) {\n        this.worktreesDir = worktreesDir;\n        this.canonicalRoot = canonicalRoot;\n        this.execPromise = execPromise;\n        this.jujutsuRepoCache = new Map();  // パスごとのキャッシュ\n    }\n\n    /**\n     * Jujutsuリポジトリかどうかを判定\n     * @param {string} repoPath - リポジトリパス\n     * @returns {Promise<boolean>}\n     */\n    async _isJujutsuRepo(repoPath) {\n        if (this.jujutsuRepoCache.has(repoPath)) {\n            return this.jujutsuRepoCache.get(repoPath);\n        }\n        try {\n            await this.execPromise(`jj -R \"${repoPath}\" version`);\n            this.jujutsuRepoCache.set(repoPath, true);\n            return true;\n        } catch {\n            this.jujutsuRepoCache.set(repoPath, false);\n            return false;\n        }\n    }\n\n    /**\n     * worktreesディレクトリが存在することを保証\n     */\n    async ensureWorktreesDir() {\n        try {\n            await fs.mkdir(this.worktreesDir, { recursive: true });\n        } catch (err) {\n            console.error('Failed to create worktrees directory:', err);\n        }\n    }\n\n    /**\n     * 新しいJujutsu workspaceを作成\n     * @param {string} sessionId - セッションID\n     * @param {string} repoPath - リポジトリパス\n     * @returns {Promise<{worktreePath: string, branchName: string, repoPath: string}|null>}\n     */\n    async create(sessionId, repoPath) {\n        await this.ensureWorktreesDir();\n\n        const repoName = path.basename(repoPath);\n        const workspaceName = `${sessionId}-${repoName}`;\n        const workspacePath = path.join(this.worktreesDir, workspaceName);\n        const bookmarkName = `session/${sessionId}`;  // Jujutsu bookmark = sessionId\n\n        try {\n            // Check if directory exists first\n            try {\n                await fs.access(repoPath);\n            } catch (accessErr) {\n                throw new Error(`Directory does not exist: ${repoPath}. Please check your project configuration in config.yml (local.path or github setting).`);\n            }\n\n            // Check if Jujutsu is available\n            const isJujutsu = await this._isJujutsuRepo(repoPath);\n            if (!isJujutsu) {\n                throw new Error(`Not a Jujutsu repository: ${repoPath}. Run 'jj git init' in the repository first.`);\n            }\n\n            // Check if workspace already exists\n            try {\n                const { stdout: workspaceList } = await this.execPromise(\n                    `jj -R \"${repoPath}\" workspace list`\n                );\n                if (workspaceList.includes(`${workspaceName}:`)) {\n                    console.log(`[workspace] Workspace already exists: ${workspaceName}, reusing`);\n                    const { stdout: startCommit } = await this.execPromise(\n                        `jj -R \"${workspacePath}\" log -r @ -T 'commit_id' --no-pager`\n                    );\n                    return { worktreePath: workspacePath, branchName: `session/${sessionId}`, repoPath, startCommit: startCommit.trim(), workspaceName };\n                }\n            } catch {\n                // Workspace doesn't exist, continue to create\n            }\n\n            // Fetch latest from remote\n            try {\n                await this.execPromise(`jj -R \"${repoPath}\" git fetch`);\n            } catch (fetchErr) {\n                console.log(`[workspace] git fetch failed, continuing: ${fetchErr.message}`);\n            }\n\n            // Create workspace\n            await this.execPromise(`jj -R \"${repoPath}\" workspace add --name \"${workspaceName}\" \"${workspacePath}\"`);\n            console.log(`[workspace] Created workspace: ${workspaceName} at ${workspacePath}`);\n\n            // Create bookmark\n            try {\n                await this.execPromise(`jj -R \"${repoPath}\" bookmark create -r main ${bookmarkName}`);\n                console.log(`[workspace] Created bookmark: ${bookmarkName}`);\n            } catch (bookmarkErr) {\n                console.log(`[workspace] Bookmark creation skipped: ${bookmarkErr.message}`);\n            }\n\n            // Create symlink for .env if it exists in the source repo\n            const sourceEnvPath = path.join(repoPath, '.env');\n            const targetEnvPath = path.join(workspacePath, '.env');\n            try {\n                await fs.access(sourceEnvPath);\n                await fs.symlink(sourceEnvPath, targetEnvPath);\n                console.log(`Created .env symlink at ${targetEnvPath}`);\n            } catch (envErr) {\n                if (envErr.code !== 'ENOENT') {\n                    console.log(`Note: Could not create .env symlink: ${envErr.message}`);\n                }\n            }\n\n            // Create symlink for .claude directory\n            const workspaceRoot = path.dirname(path.dirname(this.worktreesDir));\n            const sourceClaudePath = path.join(workspaceRoot, '.claude');\n            const targetClaudePath = path.join(workspacePath, '.claude');\n            try {\n                await fs.access(sourceClaudePath);\n                try {\n                    await fs.access(targetClaudePath);\n                    console.log(`.claude already exists at ${targetClaudePath}, skipping symlink`);\n                } catch {\n                    await fs.symlink(sourceClaudePath, targetClaudePath);\n                    console.log(`Created .claude symlink at ${targetClaudePath}`);\n                }\n            } catch (claudeErr) {\n                if (claudeErr.code === 'ENOENT') {\n                    console.log(`Note: .claude directory not found at ${sourceClaudePath}`);\n                } else {\n                    console.log(`Note: Could not create .claude symlink: ${claudeErr.message}`);\n                }\n            }\n\n            // Get current HEAD as startCommit\n            const { stdout: startCommit } = await this.execPromise(\n                `jj -R \"${workspacePath}\" log -r @ -T 'commit_id' --no-pager`\n            );\n\n            console.log(`Created Jujutsu workspace at ${workspacePath}`);\n            return { worktreePath: workspacePath, branchName: `session/${sessionId}`, repoPath, startCommit: startCommit.trim(), workspaceName };\n        } catch (err) {\n            console.error(`Failed to create workspace for ${sessionId}:`, err.message);\n            return null;\n        }\n    }\n\n    /**\n     * Jujutsu workspaceを削除\n     * @param {string} sessionId - セッションID\n     * @param {string} repoPath - リポジトリパス\n     * @returns {Promise<boolean>}\n     */\n    async remove(sessionId, repoPath) {\n        const repoName = path.basename(repoPath);\n        const workspaceName = `${sessionId}-${repoName}`;\n        const workspacePath = path.join(this.worktreesDir, workspaceName);\n        const bookmarkName = `session/${sessionId}`;\n\n        try {\n            // Forget workspace (metadata only)\n            try {\n                await this.execPromise(`jj -R \"${repoPath}\" workspace forget \"${workspaceName}\"`);\n                console.log(`[workspace] Forgot workspace: ${workspaceName}`);\n            } catch (forgetErr) {\n                console.log(`[workspace] Workspace forget skipped: ${forgetErr.message}`);\n            }\n\n            // Delete bookmark\n            try {\n                await this.execPromise(`jj -R \"${repoPath}\" bookmark delete \"${bookmarkName}\"`);\n                console.log(`[workspace] Deleted bookmark: ${bookmarkName}`);\n            } catch (bookmarkErr) {\n                console.log(`[workspace] Bookmark deletion skipped: ${bookmarkErr.message}`);\n            }\n\n            // Remove physical directory\n            try {\n                await fs.rm(workspacePath, { recursive: true, force: true });\n                console.log(`[workspace] Removed physical directory: ${workspacePath}`);\n            } catch (rmErr) {\n                console.log(`[workspace] Directory removal skipped: ${rmErr.message}`);\n            }\n\n            return true;\n        } catch (err) {\n            console.error(`Failed to remove workspace for ${sessionId}:`, err.message);\n            return false;\n        }\n    }\n\n    /**\n     * Jujutsu workspaceの状態を取得\n     * @param {string} sessionId - セッションID\n     * @param {string} repoPath - リポジトリパス\n     * @param {string|null} startCommit - セッション開始時のコミットハッシュ\n     * @returns {Promise<Object>} workspace状態情報\n     */\n    async getStatus(sessionId, repoPath, startCommit = null) {\n        const repoName = path.basename(repoPath);\n        const workspaceName = `${sessionId}-${repoName}`;\n        const workspacePath = path.join(this.worktreesDir, workspaceName);\n        const bookmarkName = `session/${sessionId}`;\n\n        try {\n            // Check if workspace exists\n            await fs.access(workspacePath);\n\n            // Get main branch name\n            const mainBranchName = await this._getMainBranchName(repoPath);\n\n            // Get changes not pushed (main..@)\n            let changesNotPushed = 0;\n            try {\n                const { stdout: aheadCount } = await this.execPromise(\n                    `jj -R \"${workspacePath}\" log -r \"${mainBranchName}..@\" -T '\"x\\n\"' --no-pager 2>/dev/null | wc -l`\n                );\n                changesNotPushed = parseInt(aheadCount.trim()) || 0;\n            } catch {\n                changesNotPushed = 0;\n            }\n\n            // Check for working copy changes (Jujutsu: working copy is always a commit)\n            let hasWorkingCopyChanges = false;\n            try {\n                const { stdout: statusOutput } = await this.execPromise(\n                    `jj -R \"${workspacePath}\" status --no-pager`\n                );\n                hasWorkingCopyChanges = statusOutput.trim().length > 0;\n            } catch {\n                hasWorkingCopyChanges = false;\n            }\n\n            // Check if bookmark exists and is pushed to remote\n            let bookmarkPushed = false;\n            try {\n                const { stdout: bookmarkList } = await this.execPromise(\n                    `jj -R \"${repoPath}\" bookmark list ${bookmarkName} --no-pager`\n                );\n                bookmarkPushed = bookmarkList.includes('origin') || bookmarkList.includes('@origin');\n            } catch {\n                bookmarkPushed = false;\n            }\n\n            // Determine if integration (push) is needed\n            const needsIntegration = changesNotPushed > 0 || hasWorkingCopyChanges || !bookmarkPushed;\n\n            return {\n                exists: true,\n                worktreePath: workspacePath,\n                workspaceName,\n                bookmarkName,\n                mainBranch: mainBranchName,\n\n                // Jujutsu概念\n                changesNotPushed,        // remoteにないchange数\n                hasWorkingCopyChanges,   // working copyに変更があるか\n                bookmarkPushed,          // bookmarkがremoteにあるか\n                needsIntegration,        // 統合（push）が必要か\n\n                // 後方互換性（非推奨、将来的に削除）\n                commitsAhead: changesNotPushed,\n                hasUncommittedChanges: hasWorkingCopyChanges,\n                branchName: `session/${sessionId}`,\n                needsMerge: needsIntegration\n            };\n        } catch (err) {\n            return {\n                exists: false,\n                worktreePath: workspacePath,\n                workspaceName,\n                bookmarkName,\n                needsIntegration: false,\n                needsMerge: false\n            };\n        }\n    }\n\n    /**\n     * ローカルmainを更新（Jujutsu: jj git fetch）\n     * @param {string} repoPath - リポジトリパス\n     * @returns {Prom\n\n\n--- server/services/goal-seek-websocket-manager.js (approx 391 lines) ---\n/**\n * GoalSeekWebSocketManager\n *\n * WebSocket接続を管理し、Goal Seek計算のリアルタイム通信を提供��\n *\n * 機能:\n * - JWT認証\n * - 計算リクエスト処理\n * - 進捗通知\n * - 介入フロー（intervention_required → intervention_response）\n * - 接続数制限\n *\n * 設計書参照: /tmp/dev-ops/spec.md § 2.2\n */\n\nimport { randomUUID } from 'crypto';\n\n// WebSocket close codes\nconst CLOSE_CODES = {\n    NORMAL: 1000,\n    AUTH_ERROR: 4001,\n    MAX_CONNECTIONS: 4002,\n    INVALID_MESSAGE: 4003,\n    INTERNAL_ERROR: 4004\n};\n\n// メッセージタイプ\nconst MESSAGE_TYPES = {\n    CALCULATE: 'calculate',\n    PROGRESS: 'progress',\n    COMPLETED: 'completed',\n    INTERVENTION_REQUIRED: 'intervention_required',\n    INTERVENTION_RESPONSE: 'intervention_response',\n    INTERVENTION_ACKNOWLEDGED: 'intervention_acknowledged',\n    CANCEL: 'cancel',\n    CANCELLED: 'cancelled',\n    ERROR: 'error'\n};\n\nexport class GoalSeekWebSocketManager {\n    /**\n     * @param {Object} options\n     * @param {Object} options.authService - 認証サービス\n     * @param {Object} options.calculationService - 計算サービス\n     * @param {number} options.maxConnections - 最大接続数\n     * @param {number} options.calculationTimeout - 計算タイムアウト(ms)\n     * @param {number} options.interventionTimeout - 介入有効期限(ms)\n     */\n    constructor(options = {}) {\n        this.authService = options.authService;\n        this.calculationService = options.calculationService;\n        this.maxConnections = options.maxConnections || 3;\n        this.calculationTimeout = options.calculationTimeout || 10000;\n        this.interventionTimeout = options.interventionTimeout || 3600000;\n\n        // 接続管理: WebSocket → { userId, role, connectedAt }\n        this.connections = new Map();\n\n        // 介入管理: interventionId → { ws, correlationId, payload, expiresAt }\n        this.pendingInterventions = new Map();\n    }\n\n    /**\n     * WebSocket接続を処理\n     *\n     * @param {WebSocket} ws - WebSocketインスタンス\n     * @param {Object} request - HTTPリクエスト\n     */\n    async handleConnection(ws, request) {\n        // 接続数チェック\n        if (this.connections.size >= this.maxConnections) {\n            this._sendError(ws, null, 'Max connections reached', CLOSE_CODES.MAX_CONNECTIONS);\n            ws.close(CLOSE_CODES.MAX_CONNECTIONS);\n            return;\n        }\n\n        // 認証\n        const authHeader = request.headers?.authorization || '';\n        const token = authHeader.startsWith('Bearer ') ? authHeader.slice(7) : null;\n\n        if (!token) {\n            this._sendError(ws, null, 'Authorization required', CLOSE_CODES.AUTH_ERROR);\n            ws.close(CLOSE_CODES.AUTH_ERROR);\n            return;\n        }\n\n        try {\n            const user = await this.authService.verifyToken(token);\n\n            // 接続を登録\n            this.connections.set(ws, {\n                userId: user.userId,\n                role: user.role,\n                connectedAt: new Date().toISOString()\n            });\n\n            // メッセージハンドラを設定\n            ws.on('message', (data) => this.handleMessage(ws, data.toString()));\n\n            // 接続成功メッセージ\n            this._send(ws, {\n                type: 'connected',\n                correlationId: randomUUID(),\n                userId: user.userId\n            });\n\n        } catch (error) {\n            this._sendError(ws, null, 'Authentication failed', CLOSE_CODES.AUTH_ERROR);\n            ws.close(CLOSE_CODES.AUTH_ERROR);\n        }\n    }\n\n    /**\n     * WebSocketメッセージを処理\n     *\n     * @param {WebSocket} ws - WebSocketインスタンス\n     * @param {string} data - メッセージデータ\n     */\n    async handleMessage(ws, data) {\n        let message;\n        let correlationId = null;\n\n        // JSONパース\n        try {\n            message = JSON.parse(data);\n            correlationId = message.correlationId;\n        } catch {\n            this._sendError(ws, null, 'Invalid JSON', null, 'INVALID_MESSAGE');\n            return;\n        }\n\n        const { type, payload } = message;\n\n        try {\n            switch (type) {\n                case MESSAGE_TYPES.CALCULATE:\n                    await this._handleCalculate(ws, correlationId, payload);\n                    break;\n\n                case MESSAGE_TYPES.INTERVENTION_RESPONSE:\n                    await this._handleInterventionResponse(ws, correlationId, payload);\n                    break;\n\n                case MESSAGE_TYPES.CANCEL:\n                    await this._handleCancel(ws, correlationId);\n                    break;\n\n                default:\n                    this._sendError(ws, correlationId, `Unknown message type: ${type}`, null, 'UNKNOWN_MESSAGE_TYPE');\n            }\n        } catch (error) {\n            this._sendError(ws, correlationId, error.message, null, 'INTERNAL_ERROR');\n        }\n    }\n\n    /**\n     * 接続切断を処理\n     *\n     * @param {WebSocket} ws - WebSocketインスタンス\n     */\n    handleDisconnect(ws) {\n        this.connections.delete(ws);\n    }\n\n    /**\n     * アクティブ接続数を取得\n     *\n     * @returns {number}\n     */\n    getActiveConnectionCount() {\n        return this.connections.size;\n    }\n\n    /**\n     * 接続情報を取得\n     *\n     * @param {WebSocket} ws\n     * @returns {Object|null}\n     */\n    getConnectionInfo(ws) {\n        return this.connections.get(ws) || null;\n    }\n\n    /**\n     * HTTP経由で介入回答を処理\n     *\n     * @param {Object} params\n     * @param {string} params.interventionId - 介入ID\n     * @param {string} params.goalId - ゴールID\n     * @param {string} params.choice - 選択（proceed, abort, modify）\n     * @param {string} params.reason - 理由（任意）\n     * @param {string} params.userId - ユーザーID\n     * @returns {Promise<Object>} 処理結果\n     */\n    async handleInterventionResponseHTTP({ interventionId, goalId, choice, reason, userId }) {\n        const pending = this.pendingInterventions.get(interventionId);\n\n        if (!pending) {\n            throw new Error('Intervention not found or expired');\n        }\n\n        // 期限チェック\n        if (Date.now() > pending.expiresAt) {\n            this.pendingInterventions.delete(interventionId);\n            throw new Error('Intervention expired');\n        }\n\n        // 所有者チェック\n        const connectionInfo = this.connections.get(pending.ws);\n        if (connectionInfo?.userId !== userId) {\n            throw new Error('Unauthorized: intervention belongs to another user');\n        }\n\n        // 介入を削除\n        this.pendingInterventions.delete(interventionId);\n\n        // WebSocket経由で通知\n        this._send(pending.ws, {\n            type: MESSAGE_TYPES.INTERVENTION_ACKNOWLEDGED,\n            correlationId: pending.correlationId,\n            interventionId,\n            choice,\n            reason,\n            source: 'http'\n        });\n\n        // 選択に応じて処理を継続\n        if (choice === 'proceed') {\n            this._send(pending.ws, {\n                type: MESSAGE_TYPES.COMPLETED,\n                correlationId: pending.correlationId,\n                result: pending.result\n            });\n        }\n\n        return {\n            interventionId,\n            goalId,\n            choice,\n            acknowledged: true\n        };\n    }\n\n    /**\n     * すべての接続を閉じてクリーンアップ\n     */\n    cleanup() {\n        for (const ws of this.connections.keys()) {\n            try {\n                ws.close(CLOSE_CODES.NORMAL);\n            } catch {\n                // ignore\n            }\n        }\n        this.connections.clear();\n        this.pendingInterventions.clear();\n    }\n\n    // ===== Private Methods =====\n\n    /**\n     * 計算リクエストを処理\n     * @private\n     */\n    async _handleCalculate(ws, correlationId, payload) {\n        const result = await this.calculationService.calculate(payload, {\n            correlationId,\n            emitProgress: true\n        });\n\n        // 介入判定\n        const intervention = this.calculationService.checkInterventionNeeded(result);\n\n        if (intervention.needed) {\n            const interventionId = randomUUID();\n            this.pendingInterventions.set(interventionId, {\n                ws,\n                correlationId,\n                payload,\n                result,\n                expiresAt: Date.now() + this.interventionTimeout\n            });\n\n            this._send(ws, {\n                type: MESSAGE_TYPES.INTERVENTION_REQUIRED,\n                correlationId,\n                intervention: {\n                    id: interventionId,\n                    type: intervention.type,\n                    reason: intervention.reason,\n                    calculation: result\n                }\n            });\n        } else {\n            this._send(ws, {\n                type: MESSAGE_TYPES.COMPLETED,\n                correlationId,\n                result\n            });\n        }\n    }\n\n    /**\n     * 介入回答を処理\n     * @private\n     */\n    async _handleInterventionResponse(ws, correlationId, payload) {\n        const { interventionId, choice } = payload;\n\n        const pending = this.pendingInterventions.get(interventionId);\n        if (!pending) {\n            this._sendError(ws, correlationId, 'Intervention not found or expired', null, 'INTERVENTION_EXPIRED');\n            return;\n        }\n\n        // 期限チェック\n        if (Date.now() > pending.expiresAt) {\n            this.pendingInterventions.delete(interventionId);\n            this._sendError(ws, correlationId, 'Intervention expired', null, 'INTERVENTION_EXPIRED');\n            return;\n        }\n\n        this.pendingInterventions.delete(interventionId);\n\n        // 回答を確認\n        this._send(ws, {\n            type: MESSAGE_TYPES.INTERVENTION_ACKNOWLEDGED,\n            correlationId,\n            interventionId,\n            choice\n        });\n\n        // 選択に応じて処理を継続（実装は要件に応じて拡張）\n        if (choice === 'proceed') {\n            this._send(ws, {\n                type: MESSAGE_TYPES.COMPLETED,\n                correlationId,\n                result: pending.result\n            });\n        }\n    }\n\n    /**\n     * キャンセルリクエストを処理\n     * @private\n     */\n    async _handleCancel(ws, correlationId) {\n        // 関連する介入があれば削除\n        for (const [id, pending] of this.pendingInterventions) {\n            if (pending.correlationId === correlationId) {\n                this.pendingInterventions.delete(id);\n                break;\n            }\n        }\n\n        this._send(ws, {\n            type: MESSAGE_TYPES.CANCELLED,\n            correlationId\n        });\n    }\n\n    /**\n     * メッセージを送信\n     * @private\n     */\n    _send(ws, data) {\n        if (ws.readyState === 1) { // OPEN\n            ws.send(JSON.stringify(data));\n        }\n    }\n\n    /**\n     * エラーメッセージを送信\n     * @private\n     */\n    _sendError(ws, correlationId, message, closeCode, code = 'ERROR') {\n        this._send(ws, {\n            type: MESSAGE_TYPES.ERROR,\n            correlationId,\n            code,\n            message\n        });\n\n        if (closeCode) {\n            ws.close(closeCode);\n        }\n    }\n}\n\nexport default GoalSeekWebSocketManager;\n\n\n\n--- server/services/goal-seek-calculation-service.js (approx 312 lines) ---\n/**\n * GoalSeekCalculationService\n *\n * 目標達成逆算計算サービス\n * 機能:\n * - calculate() - 目標達成に必要な日次アクションを逆算\n * - checkInterventionNeeded() - 人介入が必要かどうか判定\n * - EventBus連携 (GOAL_SEEK_STARTED, GOAL_SEEK_PROGRESS, GOAL_SEEK_COMPLETED)\n */\n\nimport { logger } from '../utils/logger.js';\n\n// 介入判定の閾値\nconst INTERVENTION_THRESHOLDS = {\n    DAILY_TARGET_MAX: 100,      // 日次アクションの上限\n    MIN_PERIOD_DAYS: 7,          // 最小期間（日）\n    HIGH_VARIATION_RATE: 0.5     // 高変動率の閾値（50%）\n};\n\n// イベント名\nconst EVENTS = {\n    GOAL_SEEK_STARTED: 'goal-seek:started',\n    GOAL_SEEK_PROGRESS: 'goal-seek:progress',\n    GOAL_SEEK_COMPLETED: 'goal-seek:completed'\n};\n\n/**\n * @typedef {Object} CalculationParams\n * @property {number} target - 目標値\n * @property {number} period - 期間（日）\n * @property {number} [current=0] - 現在値\n * @property {string} [unit='件'] - 単位\n * @property {string} [variable] - 変数名\n */\n\n/**\n * @typedef {Object} CalculationResult\n * @property {number} dailyTarget - 日次目標\n * @property {number} totalDays - 総日数\n * @property {number} remainingDays - 残日数\n * @property {number} completed - 達成済み\n * @property {number} remaining - 残り\n * @property {string} unit - 単位\n * @property {boolean} isCompleted - 完了フラグ\n * @property {string} [correlationId] - 相関ID\n * @property {number} [achievableProbability] - 達成確率\n * @property {Object} [gap] - ギャップ情報\n * @property {Object} [projection] - 投影情報\n */\n\n/**\n * @typedef {Object} InterventionResult\n * @property {boolean} needed - 介入が必要か\n * @property {string} [type] - 介入タイプ (decision, blocker, confirmation)\n * @property {string} [reason] - 介入理由\n * @property {Object} [details] - 詳細情報\n */\n\nexport class GoalSeekCalculationService {\n    /**\n     * @param {Object} options\n     * @param {Object} [options.eventBus] - EventBusインスタンス\n     */\n    constructor(options = {}) {\n        this.eventBus = options.eventBus || null;\n        this.thresholds = { ...INTERVENTION_THRESHOLDS };\n    }\n\n    /**\n     * 目標達成逆算計算を実行\n     * @param {CalculationParams} params - 計算パラメータ\n     * @param {Object} [options={}] - オプション\n     * @param {string} [options.correlationId] - 相関ID\n     * @param {boolean} [options.emitProgress=false] - 進捗イベントを発行するか\n     * @returns {Promise<CalculationResult>} 計算結果\n     */\n    async calculate(params, options = {}) {\n        const {\n            target,\n            period,\n            current = 0,\n            unit = '件',\n            variable\n        } = params;\n\n        const { correlationId, emitProgress = false } = options;\n\n        // パラメータバリデーション\n        this._validateParams({ target, period, current });\n\n        // 開始イベント発行\n        if (this.eventBus) {\n            this.eventBus.emit(EVENTS.GOAL_SEEK_STARTED, {\n                target,\n                period,\n                current,\n                unit,\n                correlationId\n            });\n        }\n\n        // 進捗イベント発行（オプション）\n        if (emitProgress && this.eventBus) {\n            this.eventBus.emit(EVENTS.GOAL_SEEK_PROGRESS, {\n                correlationId,\n                progress: 0,\n                step: 'validating'\n            });\n        }\n\n        // 計算実行\n        const result = this._performCalculation({\n            target,\n            period,\n            current,\n            unit,\n            variable,\n            correlationId\n        });\n\n        // 進捗イベント発行（オプション）\n        if (emitProgress && this.eventBus) {\n            this.eventBus.emit(EVENTS.GOAL_SEEK_PROGRESS, {\n                correlationId,\n                progress: 100,\n                step: 'completed'\n            });\n        }\n\n        // 完了イベント発行\n        if (this.eventBus) {\n            this.eventBus.emit(EVENTS.GOAL_SEEK_COMPLETED, {\n                correlationId,\n                result\n            });\n        }\n\n        logger.info('GoalSeek calculation completed', {\n            target,\n            period,\n            current,\n            dailyTarget: result.dailyTarget,\n            correlationId\n        });\n\n        return result;\n    }\n\n    /**\n     * 人介入が必要かどうか判定\n     * @param {Object} calculationResult - 計算結果\n     * @returns {InterventionResult} 介入判定結果\n     */\n    checkInterventionNeeded(calculationResult) {\n        const { dailyTarget, totalDays, isCompleted, hasBlocker, blockerReason } = calculationResult;\n\n        // 完了済みの場合は介入不要\n        if (isCompleted) {\n            return { needed: false };\n        }\n\n        // ブロッカーがある場合\n        if (hasBlocker) {\n            return {\n                needed: true,\n                type: 'blocker',\n                reason: blockerReason || 'Blocker detected',\n                details: { blockerReason }\n            };\n        }\n\n        // 日次目標が閾値を超える場合\n        if (dailyTarget > this.thresholds.DAILY_TARGET_MAX) {\n            return {\n                needed: true,\n                type: 'decision',\n                reason: `dailyTarget (${dailyTarget.toFixed(2)}) exceeds threshold (${this.thresholds.DAILY_TARGET_MAX})`,\n                details: {\n                    dailyTarget,\n                    threshold: this.thresholds.DAILY_TARGET_MAX\n                }\n            };\n        }\n\n        // 期間が極端に短い場合\n        if (totalDays && totalDays < this.thresholds.MIN_PERIOD_DAYS) {\n            return {\n                needed: true,\n                type: 'confirmation',\n                reason: `period (${totalDays} days) is shorter than minimum (${this.thresholds.MIN_PERIOD_DAYS} days)`,\n                details: {\n                    totalDays,\n                    minPeriod: this.thresholds.MIN_PERIOD_DAYS\n                }\n            };\n        }\n\n        return { needed: false };\n    }\n\n    /**\n     * パラメータをバリデーション\n     * @param {Object} params - パラメータ\n     * @throws {Error} バリデーションエラー\n     * @private\n     */\n    _validateParams({ target, period, current }) {\n        // target検証\n        if (typeof target !== 'number' || target < 0) {\n            throw new Error('target must be >= 0');\n        }\n\n        // period検証\n        if (typeof period !== 'number' || period < 1 || period > 365) {\n            throw new Error('period must be between 1 and 365');\n        }\n\n        // current検証\n        if (typeof current !== 'number' || current < 0) {\n            throw new Error('current must be >= 0');\n        }\n    }\n\n    /**\n     * 計算を実行\n     * @param {Object} params - 計算パラメータ\n     * @returns {CalculationResult} 計算結果\n     * @private\n     */\n    _performCalculation({ target, period, current, unit, variable, correlationId }) {\n        const remaining = Math.max(0, target - current);\n        const isCompleted = current >= target;\n        const dailyTarget = isCompleted ? 0 : remaining / period;\n\n        // 達成確率の計算（簡易版：日次目標に基づく）\n        const achievableProbability = this._calculateProbability(dailyTarget, period);\n\n        // ギャップ情報\n        const gap = {\n            value: remaining,\n            percentage: target > 0 ? Math.round((remaining / target) * 100) : 0\n        };\n\n        // 投影情報（将来予測）\n        const projection = this._createProjection(dailyTarget, period, current, target);\n\n        return {\n            dailyTarget: Math.round(dailyTarget * 100) / 100, // 小数点2桁に丸める\n            totalDays: period,\n            remainingDays: period,\n            completed: current,\n            remaining,\n            unit,\n            isCompleted,\n            correlationId,\n            achievableProbability,\n            gap,\n            projection,\n            variable\n        };\n    }\n\n    /**\n     * 達成確率を計算\n     * @param {number} dailyTarget - 日次目標\n     * @param {number} period - 期間\n     * @returns {number} 達成確率（0-100）\n     * @private\n     */\n    _calculateProbability(dailyTarget, period) {\n        // 日次目標が高いほど確率が低くなる簡易モデル\n        if (dailyTarget === 0) return 100;\n        if (dailyTarget <= 10) return 95;\n        if (dailyTarget <= 30) return 80;\n        if (dailyTarget <= 50) return 60;\n        if (dailyTarget <= 100) return 40;\n        return Math.max(5, 100 - dailyTarget);\n    }\n\n    /**\n     * 投影情報を作成\n     * @param {number} dailyTarget - 日次目標\n     * @param {number} period - 期間\n     * @param {number} current - 現在値\n     * @param {number} target - 目標値\n     * @returns {Object} 投影情報\n     * @private\n     */\n    _createProjection(dailyTarget, period, current, target) {\n        const milestones = [];\n        const step = Math.max(1, Math.floor(period / 4)); // 4段階のマイルストーン\n\n        for (let i = 1; i <= 4; i++) {\n            const day = step * i;\n            const projected = Math.min(target, current + (dailyTarget * day));\n            milestones.push({\n                day,\n                projected: Math.round(projected * 100) / 100,\n                percentage: target > 0 ? Math.round((projected / target) * 100) : 0\n            });\n        }\n\n        return {\n            milestones,\n            estimatedCompletion: period,\n            confidenceLevel: dailyTarget <= 50 ? 'high' : dailyTarget <= 100 ? 'medium' : 'low'\n        };\n    }\n}\n\nexport default GoalSeekCalculationService;\n\n\n\n--- server/services/config-service.js (approx 272 lines) ---\nimport fs from 'fs/promises';\nimport path from 'path';\nimport yaml from 'js-yaml';\n\n/**\n * ConfigService\n * config.yml の更新を安全に行うサービス\n */\nexport class ConfigService {\n    constructor(configPath, projectsRoot = null) {\n        this.configPath = configPath;\n        this.projectsRoot = projectsRoot;\n    }\n\n    async _loadConfig() {\n        const content = await fs.readFile(this.configPath, 'utf-8');\n        const data = yaml.load(content) || {};\n        return { data, content };\n    }\n\n    async _saveConfig(data) {\n        // backup\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n        const backupPath = `${this.configPath}.bak-${timestamp}`;\n        await fs.copyFile(this.configPath, backupPath);\n\n        const nextYaml = yaml.dump(data, { lineWidth: -1, noRefs: true });\n        await fs.writeFile(this.configPath, nextYaml, 'utf-8');\n    }\n\n    _getProjects(data) {\n        if (!Array.isArray(data.projects)) {\n            data.projects = [];\n        }\n        return data.projects;\n    }\n\n    _findProject(projects, projectId) {\n        return projects.find(p => p.id === projectId);\n    }\n\n    _normalizeProjectPath(localPath, data) {\n        if (!localPath) return localPath;\n        if (!this.projectsRoot) return localPath;\n        const projectsRootConfig = data.projects_root || '';\n        if (!projectsRootConfig.includes('${PROJECTS_ROOT')) {\n            return localPath;\n        }\n        if (localPath.startsWith(this.projectsRoot)) {\n            const suffix = localPath.slice(this.projectsRoot.length).replace(/^\\/+/, '');\n            return `${projectsRootConfig}/${suffix}`.replace(/\\/+$/, '');\n        }\n        return localPath;\n    }\n\n    async upsertGitHubMapping({ project_id, owner, repo, branch }) {\n        if (!project_id || !owner || !repo) {\n            throw new Error('project_id, owner, repo are required');\n        }\n\n        const { data } = await this._loadConfig();\n        const projects = this._getProjects(data);\n        const project = this._findProject(projects, project_id);\n        if (!project) {\n            throw new Error(`Project not found: ${project_id}`);\n        }\n\n        project.github = {\n            owner,\n            repo,\n            branch: branch || 'main'\n        };\n\n        await this._saveConfig(data);\n        return project.github;\n    }\n\n    async deleteGitHubMapping(projectId) {\n        if (!projectId) {\n            throw new Error('project_id is required');\n        }\n\n        const { data } = await this._loadConfig();\n        const projects = this._getProjects(data);\n        const project = this._findProject(projects, projectId);\n        if (!project) {\n            throw new Error(`Project not found: ${projectId}`);\n        }\n\n        delete project.github;\n        await this._saveConfig(data);\n        return true;\n    }\n\n    async upsertNocoDBMapping({ project_id, base_id, nocodb_project_id, base_name, url }) {\n        if (!project_id || !nocodb_project_id) {\n            throw new Error('project_id, nocodb_project_id are required');\n        }\n\n        const { data } = await this._loadConfig();\n        const projects = this._getProjects(data);\n        const project = this._findProject(projects, project_id);\n        if (!project) {\n            throw new Error(`Project not found: ${project_id}`);\n        }\n\n        project.nocodb = {\n            base_id: base_id || '',\n            project_id: nocodb_project_id,\n            base_name: base_name || '',\n            url: url || ''\n        };\n\n        await this._saveConfig(data);\n        return project.nocodb;\n    }\n\n    async deleteNocoDBMapping(projectId) {\n        if (!projectId) {\n            throw new Error('project_id is required');\n        }\n\n        const { data } = await this._loadConfig();\n        const projects = this._getProjects(data);\n        const project = this._findProject(projects, projectId);\n        if (!project) {\n            throw new Error(`Project not found: ${projectId}`);\n        }\n\n        delete project.nocodb;\n        await this._saveConfig(data);\n        return true;\n    }\n\n    async upsertProject({ id, emoji, local_path, glob_include, archived }) {\n        if (!id || !local_path) {\n            throw new Error('id and local_path are required');\n        }\n\n        const { data } = await this._loadConfig();\n        const projects = this._getProjects(data);\n        const existing = this._findProject(projects, id);\n        const normalizedPath = this._normalizeProjectPath(local_path, data);\n        const nextGlob = Array.isArray(glob_include) ? glob_include : [];\n\n        if (existing) {\n            existing.emoji = emoji || existing.emoji || '';\n            existing.archived = Boolean(archived);\n            existing.local = {\n                ...(existing.local || {}),\n                path: normalizedPath,\n                glob_include: nextGlob\n            };\n        } else {\n            projects.push({\n                id,\n                emoji: emoji || '',\n                archived: Boolean(archived),\n                local: {\n                    path: normalizedPath,\n                    glob_include: nextGlob\n                }\n            });\n        }\n\n        await this._saveConfig(data);\n        return { id };\n    }\n\n    async deleteProject(projectId) {\n        if (!projectId) {\n            throw new Error('id is required');\n        }\n\n        const { data } = await this._loadConfig();\n        const projects = this._getProjects(data);\n        const next = projects.filter(p => p.id !== projectId);\n        if (next.length === projects.length) {\n            throw new Error(`Project not found: ${projectId}`);\n        }\n        data.projects = next;\n        await this._saveConfig(data);\n        return true;\n    }\n\n    async upsertOrganization({ id, name, ceo, projects }) {\n        if (!id) {\n            throw new Error('id is required');\n        }\n\n        const { data } = await this._loadConfig();\n        if (!Array.isArray(data.organizations)) {\n            data.organizations = [];\n        }\n\n        const org = data.organizations.find(o => o.id === id);\n        const normalizedProjects = Array.isArray(projects) ? projects.filter(Boolean) : [];\n        const payload = {\n            id,\n            name: name || id,\n            ceo: ceo || '',\n            projects: normalizedProjects\n        };\n\n        if (org) {\n            Object.assign(org, payload);\n        } else {\n            data.organizations.push(payload);\n        }\n\n        await this._saveConfig(data);\n        return payload;\n    }\n\n    async deleteOrganization(id) {\n        if (!id) {\n            throw new Error('id is required');\n        }\n\n        const { data } = await this._loadConfig();\n        if (!Array.isArray(data.organizations)) {\n            data.organizations = [];\n        }\n\n        const next = data.organizations.filter(o => o.id !== id);\n        if (next.length === data.organizations.length) {\n            throw new Error(`Organization not found: ${id}`);\n        }\n\n        data.organizations = next;\n        await this._saveConfig(data);\n        return true;\n    }\n\n    async updateNotifications({ channels = {}, dnd = {} }) {\n        const { data } = await this._loadConfig();\n        const current = data.notifications || {\n            channels: {},\n            dnd: {}\n        };\n\n        const nextChannels = {\n            ...current.channels,\n            ...channels\n        };\n\n        const nextDnd = {\n            ...current.dnd,\n            ...dnd\n        };\n\n        const normalizedStart = Number.isFinite(Number(nextDnd.start))\n            ? Number(nextDnd.start)\n            : (Number.isFinite(Number(current.dnd?.start)) ? Number(current.dnd.start) : null);\n        const normalizedEnd = Number.isFinite(Number(nextDnd.end))\n            ? Number(nextDnd.end)\n            : (Number.isFinite(Number(current.dnd?.end)) ? Number(current.dnd.end) : null);\n\n        data.notifications = {\n            channels: nextChannels,\n            dnd: {\n                enabled: Boolean(nextDnd.enabled),\n                start: normalizedStart,\n                end: normalizedEnd\n            }\n        };\n\n        await this._saveConfig(data);\n        return data.notifications;\n    }\n}\n\n\n\n--- server/services/github-service.js (approx 264 lines) ---\nimport { Octokit } from '@octokit/rest';\n\n/**\n * GitHub API Service\n * GitHub Actionsセルフホストランナーとワークフロー情報を取得\n */\nexport class GitHubService {\n    constructor() {\n        this.token = process.env.GITHUB_TOKEN;\n        if (!this.token) {\n            console.warn('[GitHubService] GITHUB_TOKEN not set. GitHub API features will be limited.');\n        }\n\n        this.octokit = new Octokit({\n            auth: this.token,\n        });\n\n        // デフォルト設定（環境変数で上書き可能）\n        this.owner = process.env.GITHUB_OWNER || 'Unson-LLC';\n        this.repo = process.env.GITHUB_REPO || 'brainbase';\n    }\n\n    /**\n     * セルフホストランナーの一覧取得\n     * @returns {Promise<Array>} ランナー情報の配列\n     */\n    async getSelfHostedRunners() {\n        if (!this.token) {\n            return { error: 'GITHUB_TOKEN not configured', runners: [] };\n        }\n\n        try {\n            const { data } = await this.octokit.rest.actions.listSelfHostedRunnersForRepo({\n                owner: this.owner,\n                repo: this.repo,\n            });\n\n            const runners = data.runners.map(runner => ({\n                id: runner.id,\n                name: runner.name,\n                os: runner.os,\n                status: runner.status, // online, offline\n                busy: runner.busy,\n                labels: runner.labels.map(l => l.name),\n            }));\n\n            return {\n                total: data.total_count,\n                runners,\n                online: runners.filter(r => r.status === 'online').length,\n                busy: runners.filter(r => r.busy).length,\n            };\n        } catch (error) {\n            console.error('[GitHubService] Failed to fetch runners:', error.message);\n            return { error: error.message, runners: [] };\n        }\n    }\n\n    /**\n     * ワークフロー実行履歴取得\n     * @param {number} limit - 取得件数（デフォルト: 10）\n     * @returns {Promise<Array>} ワークフロー実行履歴\n     */\n    async getWorkflowRuns(limit = 10) {\n        if (!this.token) {\n            return { error: 'GITHUB_TOKEN not configured', runs: [] };\n        }\n\n        try {\n            const { data } = await this.octokit.rest.actions.listWorkflowRunsForRepo({\n                owner: this.owner,\n                repo: this.repo,\n                per_page: limit,\n            });\n\n            const runs = data.workflow_runs.map(run => ({\n                id: run.id,\n                name: run.name,\n                status: run.status, // queued, in_progress, completed\n                conclusion: run.conclusion, // success, failure, cancelled, skipped\n                createdAt: run.created_at,\n                updatedAt: run.updated_at,\n                htmlUrl: run.html_url,\n                event: run.event, // push, pull_request, schedule, etc.\n            }));\n\n            const summary = {\n                total: runs.length,\n                success: runs.filter(r => r.conclusion === 'success').length,\n                failure: runs.filter(r => r.conclusion === 'failure').length,\n                inProgress: runs.filter(r => r.status === 'in_progress').length,\n            };\n\n            return {\n                runs,\n                summary,\n            };\n        } catch (error) {\n            console.error('[GitHubService] Failed to fetch workflow runs:', error.message);\n            return { error: error.message, runs: [] };\n        }\n    }\n\n    /**\n     * 特定のワークフローの実行履歴取得\n     * @param {string} workflowId - ワークフローID（ファイル名 or ID）\n     * @param {number} limit - 取得件数\n     * @returns {Promise<Array>} ワークフロー実行履歴\n     */\n    async getWorkflowRunsByName(workflowId, limit = 10) {\n        if (!this.token) {\n            return { error: 'GITHUB_TOKEN not configured', runs: [] };\n        }\n\n        try {\n            const { data } = await this.octokit.rest.actions.listWorkflowRuns({\n                owner: this.owner,\n                repo: this.repo,\n                workflow_id: workflowId,\n                per_page: limit,\n            });\n\n            const runs = data.workflow_runs.map(run => ({\n                id: run.id,\n                name: run.name,\n                status: run.status,\n                conclusion: run.conclusion,\n                createdAt: run.created_at,\n                updatedAt: run.updated_at,\n                htmlUrl: run.html_url,\n            }));\n\n            return { runs };\n        } catch (error) {\n            console.error(`[GitHubService] Failed to fetch workflow runs for ${workflowId}:`, error.message);\n            return { error: error.message, runs: [] };\n        }\n    }\n\n    /**\n     * Healthcheckワークフローの最新実行結果取得\n     * mana（Slack Bot）とself-hosted runnersの健全性をチェック\n     * @returns {Promise<Object>} ヘルスチェック結果\n     */\n    async getHealthcheckStatus() {\n        if (!this.token) {\n            return {\n                status: 'unknown',\n                message: 'GITHUB_TOKEN not configured',\n                lastRun: null,\n            };\n        }\n\n        try {\n            // brainbase-workspaceリポジトリのhealthcheckワークフロー取得\n            const { data } = await this.octokit.rest.actions.listWorkflowRuns({\n                owner: this.owner,\n                repo: 'brainbase-workspace',\n                workflow_id: 'actions-healthcheck.yml',\n                per_page: 1,\n                branch: 'main',\n            });\n\n            if (data.workflow_runs.length === 0) {\n                return {\n                    status: 'unknown',\n                    message: 'No healthcheck runs found',\n                    lastRun: null,\n                };\n            }\n\n            const latestRun = data.workflow_runs[0];\n\n            // Job情報を取得して詳細を確認\n            const { data: jobsData } = await this.octokit.rest.actions.listJobsForWorkflowRun({\n                owner: this.owner,\n                repo: 'brainbase-workspace',\n                run_id: latestRun.id,\n            });\n\n            const failedSteps = [];\n            const allSteps = []; // 追加: 全ステップ情報\n            const jobSummary = jobsData.jobs.map(job => {\n                const failed = job.steps.filter(step => step.conclusion === 'failure');\n                failedSteps.push(...failed.map(step => ({\n                    jobName: job.name,\n                    stepName: step.name,\n                    conclusion: step.conclusion,\n                })));\n\n                // 追加: 全ステップを記録\n                allSteps.push(...job.steps.map(step => ({\n                    jobName: job.name,\n                    stepName: step.name,\n                    conclusion: step.conclusion,\n                    status: step.status,\n                })));\n\n                return {\n                    name: job.name,\n                    conclusion: job.conclusion,\n                    failedSteps: failed.length,\n                    steps: job.steps.map(s => ({ // 追加: Job内の全ステップ\n                        name: s.name,\n                        conclusion: s.conclusion,\n                        status: s.status,\n                    })),\n                };\n            });\n\n            // ステータス判定\n            const status = latestRun.conclusion === 'success' ? 'healthy' :\n                          latestRun.conclusion === 'failure' ? 'error' : 'warning';\n\n            // manaとrunnersのステップを個別に評価\n            const manaStep = allSteps.find(s => s.stepName === 'Check Lambda errors');\n            const runnersStep = allSteps.find(s => s.stepName === 'Check workflows and runners');\n\n            const manaStatus = manaStep ?\n                (manaStep.conclusion === 'success' ? 'healthy' :\n                 manaStep.conclusion === 'failure' ? 'error' : 'warning') : 'unknown';\n\n            const runnersStatus = runnersStep ?\n                (runnersStep.conclusion === 'success' ? 'healthy' :\n                 runnersStep.conclusion === 'failure' ? 'error' : 'warning') : 'unknown';\n\n            return {\n                status,\n                lastRun: {\n                    id: latestRun.id,\n                    created_at: latestRun.created_at,\n                    updated_at: latestRun.updated_at,\n                    conclusion: latestRun.conclusion,\n                    html_url: latestRun.html_url,\n                },\n                jobs: jobSummary,\n                failedSteps: failedSteps,\n                allSteps: allSteps,\n                // 個別ステータス\n                mana: {\n                    status: manaStatus,\n                    step: manaStep || null,\n                },\n                runners: {\n                    status: runnersStatus,\n                    step: runnersStep || null,\n                },\n                summary: {\n                    totalJobs: jobsData.jobs.length,\n                    failedJobs: jobsData.jobs.filter(j => j.conclusion === 'failure').length,\n                    failedStepsCount: failedSteps.length,\n                },\n            };\n        } catch (error) {\n            console.error('[GitHubService] Failed to fetch healthcheck status:', error.message);\n            return {\n                status: 'error',\n                message: error.message,\n                lastRun: null,\n            };\n        }\n    }\n}\n\n\n\n--- server/services/storage-service.js (approx 180 lines) ---\nimport { exec } from 'child_process';\nimport util from 'util';\nimport path from 'path';\n\nconst execPromise = util.promisify(exec);\n\n/**\n * Storage Management Service\n * ディスク使用量、大きなファイル検出、クリーンアップ候補の特定\n */\nexport class StorageService {\n    constructor(workspaceDir = process.env.WORKSPACE_ROOT || '/path/to/workspace') {\n        this.workspaceDir = workspaceDir;\n        this.worktreesDir = path.join(workspaceDir, '.worktrees');\n    }\n\n    /**\n     * ディレクトリサイズ取得\n     * @param {string} dir - ディレクトリパス\n     * @returns {Promise<Object>} サイズ情報\n     */\n    async getDirectorySize(dir) {\n        try {\n            const { stdout } = await execPromise(`du -sh \"${dir}\"`);\n            // 出力例: \"1.5G    /path/to/dir\"\n            const [size, dirPath] = stdout.trim().split(/\\s+/);\n\n            return {\n                path: dirPath || dir,\n                size,\n                sizeBytes: await this.getDirectorySizeInBytes(dir),\n            };\n        } catch (error) {\n            console.error(`[StorageService] Failed to get directory size for ${dir}:`, error.message);\n            return { error: error.message, size: '0' };\n        }\n    }\n\n    /**\n     * ディレクトリサイズをバイト数で取得\n     * @param {string} dir - ディレクトリパス\n     * @returns {Promise<number>} バイト数\n     */\n    async getDirectorySizeInBytes(dir) {\n        try {\n            const { stdout } = await execPromise(`du -sk \"${dir}\"`);\n            // 出力例: \"1234567    /path/to/dir\"\n            const [sizeKB] = stdout.trim().split(/\\s+/);\n            return parseInt(sizeKB) * 1024;\n        } catch (error) {\n            return 0;\n        }\n    }\n\n    /**\n     * workspace全体のストレージ情報取得\n     * @returns {Promise<Object>} ストレージ情報\n     */\n    async getWorkspaceStorage() {\n        try {\n            const [workspace, worktrees] = await Promise.all([\n                this.getDirectorySize(this.workspaceDir),\n                this.getDirectorySize(this.worktreesDir),\n            ]);\n\n            return {\n                workspace,\n                worktrees,\n                total: workspace.sizeBytes + worktrees.sizeBytes,\n            };\n        } catch (error) {\n            console.error('[StorageService] Failed to get workspace storage:', error.message);\n            return { error: error.message };\n        }\n    }\n\n    /**\n     * 大きなファイル検出（100MB以上）\n     * @param {string} dir - 検索ディレクトリ\n     * @param {number} sizeThresholdMB - サイズ閾値（MB、デフォルト: 100）\n     * @returns {Promise<Array>} 大きなファイルのリスト\n     */\n    async findLargeFiles(dir = this.workspaceDir, sizeThresholdMB = 100) {\n        try {\n            // node_modules, .git などを除外して検索\n            const { stdout } = await execPromise(\n                `find \"${dir}\" -type f -size +${sizeThresholdMB}M 2>/dev/null | grep -v node_modules | grep -v .git | head -20`\n            );\n\n            if (!stdout.trim()) {\n                return [];\n            }\n\n            const files = stdout.trim().split('\\n');\n            const fileDetails = await Promise.all(\n                files.map(async (filePath) => {\n                    try {\n                        const { stdout: sizeOutput } = await execPromise(`du -sh \"${filePath}\"`);\n                        const [size] = sizeOutput.trim().split(/\\s+/);\n                        return {\n                            path: filePath.replace(this.workspaceDir, ''),\n                            fullPath: filePath,\n                            size,\n                        };\n                    } catch {\n                        return null;\n                    }\n                })\n            );\n\n            return fileDetails.filter(f => f !== null);\n        } catch (error) {\n            console.error('[StorageService] Failed to find large files:', error.message);\n            return [];\n        }\n    }\n\n    /**\n     * worktreeごとのサイズ取得\n     * @returns {Promise<Array>} worktree情報\n     */\n    async getWorktreesSizes() {\n        try {\n            const { stdout } = await execPromise(`ls -1 \"${this.worktreesDir}\"`);\n            const worktrees = stdout.trim().split('\\n').filter(Boolean);\n\n            const sizes = await Promise.all(\n                worktrees.map(async (worktree) => {\n                    const worktreePath = path.join(this.worktreesDir, worktree);\n                    const sizeInfo = await this.getDirectorySize(worktreePath);\n\n                    return {\n                        name: worktree,\n                        size: sizeInfo.size,\n                        sizeBytes: sizeInfo.sizeBytes,\n                        path: worktreePath,\n                    };\n                })\n            );\n\n            // サイズ順にソート\n            return sizes.sort((a, b) => b.sizeBytes - a.sizeBytes);\n        } catch (error) {\n            console.error('[StorageService] Failed to get worktrees sizes:', error.message);\n            return [];\n        }\n    }\n\n    /**\n     * ストレージサマリー取得\n     * @returns {Promise<Object>} ストレージサマリー\n     */\n    async getStorageSummary() {\n        const [workspace, largeFiles, worktrees] = await Promise.all([\n            this.getWorkspaceStorage(),\n            this.findLargeFiles(),\n            this.getWorktreesSizes(),\n        ]);\n\n        return {\n            workspace,\n            largeFiles,\n            worktrees,\n        };\n    }\n\n    /**\n     * バイト数を人間が読める形式に変換\n     * @param {number} bytes - バイト数\n     * @returns {string} フォーマットされた文字列\n     */\n    formatBytes(bytes) {\n        if (bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n    }\n}\n\n\n\n上記のコードを分析し、以下を実行してください:\n1. リファクタリング機会を特定\n2. 実際にコードを改善（重複削除、命名改善、複雑度削減）\n3. 変更内容をJSON形式で出力\n\nIMPORTANT: Editツールを使って実際にファイルを修正してください！\n\n出力形式:\n{\n  \"refactored\": true/false,\n  \"files_modified\": [\"path/to/file\"],\n  \"changes_summary\": \"変更内容の説明\",\n  \"area\": \"server/services\"\n}\nmcp: nocodb starting\nmcp: freee starting\nmcp: google-calendar starting\nmcp: jibble starting\nmcp: chrome-devtools starting\nmcp: airtable starting\nmcp: brainbase starting\nmcp: gmail starting\nmcp: nocodb ready\nmcp: chrome-devtools ready\nmcp: jibble ready\nmcp: airtable ready\nmcp: brainbase ready\nmcp: gmail ready\nmcp: google-calendar ready\nmcp: freee ready\nmcp startup: ready: nocodb, chrome-devtools, jibble, airtable, brainbase, gmail, google-calendar, freee\n2026-02-14T03:18:25.764407Z ERROR codex_api::endpoint::responses: error=http 429 Too Many Requests: Some(\"{\\\"error\\\":{\\\"type\\\":\\\"usage_limit_reached\\\",\\\"message\\\":\\\"The usage limit has been reached\\\",\\\"plan_type\\\":\\\"pro\\\",\\\"resets_at\\\":1771289246,\\\"eligible_promo\\\":null,\\\"resets_in_seconds\\\":250141}}\")\nERROR: You've hit your usage limit. Visit https://chatgpt.com/codex/settings/usage to purchase more credits or try again at Feb 17th, 2026 9:47 AM.\nWarning: no last agent message; wrote empty content to /Users/ksato/actions-runner/_work/brainbase/brainbase/.codex-last-message-1771039101875-gy42fd19nc.txt\n",
        "timeoutMs": 1200000
      }
    }
  },
  "timestamp": "2026-02-14T03:18:25.849Z",
  "workflow": "ops-department-auto-refactoring-daily.yml",
  "runId": "22010175043",
  "runNumber": "11",
  "eventName": "schedule"
}